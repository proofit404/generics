{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Generics \u00b6 A classy toolkit designed with OOP in mind. Documentation | Source Code | Task Tracker In our opinion, main benefits of having objects implemented in the language are encapsulation and polymorphous. Classes that could be easily used in a composition are tricky to write. The generics library aims to help you in writing code with high quality. Pros \u00b6 Real private attributes without loosing the readability Leads to a better design forcing you to use encapsulation properly Makes writing quality code with high cohesion and low coupling easier Guides you to follow SOLID principles Example \u00b6 The generics library gives you an easy way to define private attributes on objects without loosing little nice things like readability. >>> from attr import attrs , attrib >>> from generics import private >>> @private ... @attrs ( frozen = True ) ... class User : ... name = attrib () ... ... def greet ( self ): ... return f 'Hello, { self . name } ' >>> user = User ( 'Jeff' ) >>> user . greet () 'Hello, Jeff' >>> hasattr ( user , 'name' ) False Questions \u00b6 If you have any questions, feel free to create an issue in our Task Tracker . We have the question label exactly for this purpose. Enterprise support \u00b6 If you have an issue with any version of the library, you can apply for a paid enterprise support contract. This will guarantee you that no breaking changes will happen to you. No matter how old version you're using at the moment. All necessary features and bug fixes will be backported in a way that serves your needs. Please contact proofit404@gmail.com if you're interested in it. License \u00b6 Generics library is offered under the two clause BSD license. \u2014 \u2b50\ufe0f \u2014 The generics library is part of the SOLID python family.","title":"Home"},{"location":"#generics","text":"A classy toolkit designed with OOP in mind. Documentation | Source Code | Task Tracker In our opinion, main benefits of having objects implemented in the language are encapsulation and polymorphous. Classes that could be easily used in a composition are tricky to write. The generics library aims to help you in writing code with high quality.","title":"Generics"},{"location":"#pros","text":"Real private attributes without loosing the readability Leads to a better design forcing you to use encapsulation properly Makes writing quality code with high cohesion and low coupling easier Guides you to follow SOLID principles","title":"Pros"},{"location":"#example","text":"The generics library gives you an easy way to define private attributes on objects without loosing little nice things like readability. >>> from attr import attrs , attrib >>> from generics import private >>> @private ... @attrs ( frozen = True ) ... class User : ... name = attrib () ... ... def greet ( self ): ... return f 'Hello, { self . name } ' >>> user = User ( 'Jeff' ) >>> user . greet () 'Hello, Jeff' >>> hasattr ( user , 'name' ) False","title":"Example"},{"location":"#questions","text":"If you have any questions, feel free to create an issue in our Task Tracker . We have the question label exactly for this purpose.","title":"Questions"},{"location":"#enterprise-support","text":"If you have an issue with any version of the library, you can apply for a paid enterprise support contract. This will guarantee you that no breaking changes will happen to you. No matter how old version you're using at the moment. All necessary features and bug fixes will be backported in a way that serves your needs. Please contact proofit404@gmail.com if you're interested in it.","title":"Enterprise support"},{"location":"#license","text":"Generics library is offered under the two clause BSD license. \u2014 \u2b50\ufe0f \u2014 The generics library is part of the SOLID python family.","title":"License"},{"location":"changelog/","text":"1.0.1 (2020-08-06) \u00b6 Bug Fixes \u00b6 fake @defended and @delegated decorators ( 2ae14e3 ) 1.0.0 (2020-07-03) \u00b6 Features \u00b6 implement @private decorator ( 1d237eb ) \u2014 \u2b50\ufe0f \u2014 The generics library is part of the SOLID python family.","title":"Changelog"},{"location":"changelog/#101-2020-08-06","text":"","title":"1.0.1 (2020-08-06)"},{"location":"changelog/#bug-fixes","text":"fake @defended and @delegated decorators ( 2ae14e3 )","title":"Bug Fixes"},{"location":"changelog/#100-2020-07-03","text":"","title":"1.0.0 (2020-07-03)"},{"location":"changelog/#features","text":"implement @private decorator ( 1d237eb ) \u2014 \u2b50\ufe0f \u2014 The generics library is part of the SOLID python family.","title":"Features"},{"location":"installation/","text":"Installation \u00b6 The generics library is available on PyPI. To install it run: pip install -U generics We use semantic release to publish packages as soon as pull requests land to the master branch. It's not necessary to use develompment version of the library. \u2014 \u2b50\ufe0f \u2014 The generics library is part of the SOLID python family.","title":"Installation"},{"location":"installation/#installation","text":"The generics library is available on PyPI. To install it run: pip install -U generics We use semantic release to publish packages as soon as pull requests land to the master branch. It's not necessary to use develompment version of the library. \u2014 \u2b50\ufe0f \u2014 The generics library is part of the SOLID python family.","title":"Installation"},{"location":"private/","text":"Private \u00b6 Why \u00b6 Object-oriented programming has a lot of advantages over procedural programming. The one of these advantages is encapsulation of data. In python encapsulation is implemented without information hiding . We lack this feature and want to fix it. Leading underscores \u00b6 The naming convention with leading underscores from pep8 does not work the way we want. For example, the code below will not hide class attributes. >>> class User : ... def __init__ ( self , name ): ... self . _name = name ... ... def greet ( self ): ... return f 'Hello, { self . _name } ' >>> user = User ( 'Jeff' ) >>> user . greet () 'Hello, Jeff' >>> user . _name # No information hiding here :( 'Jeff' It may be a nice convention to have it in the code base, but it does not work (it does not make architecture any better) it harms readability (underscores are ugly) Principles \u00b6 All methods are public All attributes are private and hidden Static methods are forbidden Class methods should return instances At least one instance method is required At least one encapsulated attribute is required Implementation inheritance is forbidden Underscore names are forbidden Prefer immutable classes All methods are public \u00b6 The main purpose of objects in object-oriented programming is in behavior they could provide to the client code. Behavior intended by object could be expressed with its methods. Thus every instance and class method of the object is public. Class should be decorated with @private function. attrs >>> from attr import attrs , attrib >>> from generics import private >>> @private ... @attrs ( frozen = True ) ... class User : ... name = attrib () ... ... def greet ( self ): ... return f 'Hello, { self . name } ' >>> User Private(User) >>> user = User ( 'Jeff' ) >>> user Private(User(name='Jeff')) >>> user . greet () 'Hello, Jeff' dataclasses >>> from dataclasses import dataclass >>> from generics import private >>> @private ... @dataclass ( frozen = True ) ... class User : ... name : str ... ... def greet ( self ): ... return f 'Hello, { self . name } ' >>> User Private(User) >>> user = User ( 'Jeff' ) >>> user Private(User(name='Jeff')) >>> user . greet () 'Hello, Jeff' pydantic >>> from pydantic import BaseModel >>> from generics import private >>> @private ... class User ( BaseModel ): ... name : str ... ... class Config : ... allow_mutation = False ... ... def greet ( self ): ... return f 'Hello, { self . name } ' >>> User Private(User) >>> user = User ( name = 'Jeff' ) >>> user Private(User(name='Jeff')) >>> user . greet () 'Hello, Jeff' All attributes are private and hidden \u00b6 The main advantage of objects in object-oriented programming is in encapsulation and information hiding . Procedural programming have a lot of problems related to coupling. All data flows directly through the execution flow. Every part of the code in this flow is highly coupled with each other because of the data they pass to each other. In opposite in the object-oriented programming we put parts of the data close to the parts of the code where it'll be used. Thus the execution flow sees only method calls. Client code does not know what data were encapsulated inside the object. And it's none of its business. Thus all attributes encapsulated inside the objects are private. The constructor is the only place where you can put anything inside the object. Own methods of the object (defined in its class) are free to use its attributes as usual. Attribute access in the client code will raise an exception. >>> user . name Traceback (most recent call last): ... AttributeError : 'Private(User)' object has no attribute 'name' Static methods are forbidden \u00b6 Good objects expose their behavior and hide their state. The behavior objects expose should be related to the state object hides. This metric is called cohesion. Static methods can't access the inner state of the object. That's why the behavior they expose doesn't relate to the object. Cohesion will go down. That's why we forbid static methods. If you need such behavior, put it outside of the class. If this behavior is neccessary in the instance method of the original class, encapsulate it. Pass that new thing to the constructor and access it in methods. attrs >>> from attr import attrs , attrib >>> from generics import private >>> @private ... @attrs ( frozen = True ) ... class User : ... name = attrib () ... ... def greet ( self ): ... return f 'Hello, { self . name } ' ... ... @staticmethod ... def is_bot (): ... return False Traceback (most recent call last): ... _generics.exceptions.GenericClassError : Do not use static methods (use composition instead) dataclasses >>> from dataclasses import dataclass >>> from generics import private >>> @private ... @dataclass ( frozen = True ) ... class User : ... name : str ... ... def greet ( self ): ... return f 'Hello, { self . name } ' ... ... @staticmethod ... def is_bot (): ... return False Traceback (most recent call last): ... _generics.exceptions.GenericClassError : Do not use static methods (use composition instead) pydantic >>> from pydantic import BaseModel >>> from generics import private >>> @private ... class User ( BaseModel ): ... name : str ... ... class Config : ... allow_mutation = False ... ... def greet ( self ): ... return f 'Hello, { self . name } ' ... ... @staticmethod ... def is_bot (): ... return False Traceback (most recent call last): ... _generics.exceptions.GenericClassError : Do not use static methods (use composition instead) Class methods should return instances \u00b6 As we mentioned earlier, objects should expose behavior. Class methods do not have access to any kind of inner state sinse there is no object encapsulating it. Thus the only kind of behavior class method should be able to do is instantiation of the object. attrs >>> from attr import attrs , attrib >>> from generics import private >>> @private ... @attrs ( frozen = True ) ... class User : ... name = attrib () ... ... def greet ( self ): ... return f 'Hello, { self . name } ' ... ... @classmethod ... def create ( cls ): ... pass >>> User . create () Traceback (most recent call last): ... _generics.exceptions.GenericInstanceError : 'create' classmethod should return an instance of the 'User' class dataclasses >>> from dataclasses import dataclass >>> from generics import private >>> @private ... @dataclass ( frozen = True ) ... class User : ... name : str ... ... def greet ( self ): ... return f 'Hello, { self . name } ' ... ... @classmethod ... def create ( cls ): ... pass >>> User . create () Traceback (most recent call last): ... _generics.exceptions.GenericInstanceError : 'create' classmethod should return an instance of the 'User' class pydantic >>> from pydantic import BaseModel >>> from generics import private >>> @private ... class User ( BaseModel ): ... name : str ... ... class Config : ... allow_mutation = False ... ... def greet ( self ): ... return f 'Hello, { self . name } ' ... ... @classmethod ... def create ( cls ): ... pass >>> User . create () Traceback (most recent call last): ... _generics.exceptions.GenericInstanceError : 'create' classmethod should return an instance of the 'User' class At least one instance method is required \u00b6 As we mention a couple of times earlier the main goal of the good objects is to expose behavior. If there is no methods defined on the class, it's not possible to expose any kind of behavior. The object becomes useless. Class methods does not count since it has a different purpose. attrs >>> from attr import attrs , attrib >>> from generics import private >>> @private ... @attrs ( frozen = True ) ... class User : ... name = attrib () ... ... @classmethod ... def create ( cls ): ... pass Traceback (most recent call last): ... _generics.exceptions.GenericClassError : Define at least one instance method dataclasses >>> from dataclasses import dataclass >>> from generics import private >>> @private ... @dataclass ( frozen = True ) ... class User : ... name : str ... ... @classmethod ... def create ( cls ): ... pass Traceback (most recent call last): ... _generics.exceptions.GenericClassError : Define at least one instance method pydantic >>> from pydantic import BaseModel >>> from generics import private >>> @private ... class User ( BaseModel ): ... name : str ... ... class Config : ... allow_mutation = False ... ... @classmethod ... def create ( cls ): ... pass Traceback (most recent call last): ... _generics.exceptions.GenericClassError : Define at least one instance method At least one encapsulated attribute is required \u00b6 The same as a previous one this rules exists because of the encapsulation restrictions. If your object does not encapsulate at least one attribute, it does not have any state. In that case behavior exposed by the object does not relate to the object itself. Thus there is no reason to define such kind of method on the class in the first place. attrs >>> from attr import attrs , attrib >>> from generics import private >>> @private ... @attrs ( frozen = True ) ... class User : ... ... def greet ( self ): ... return 'Hello, Jeff' Traceback (most recent call last): ... _generics.exceptions.GenericClassError : Define at least one encapsulated attribute dataclasses >>> from dataclasses import dataclass >>> from generics import private >>> @private ... @dataclass ( frozen = True ) ... class User : ... ... def greet ( self ): ... return 'Hello, Jeff' Traceback (most recent call last): ... _generics.exceptions.GenericClassError : Define at least one encapsulated attribute pydantic >>> from pydantic import BaseModel >>> from generics import private >>> @private ... class User ( BaseModel ): ... ... def greet ( self ): ... return 'Hello, Jeff' Traceback (most recent call last): ... _generics.exceptions.GenericClassError : Define at least one encapsulated attribute Implementation inheritance is forbidden \u00b6 First of all, there are two types of inheritance - subtyping inheritance and implementation inheritance . It's nothing wrong with subtyping inheritance. It's used to create \"is a\" relationship between classes. It's a technique where you can say that this class is an implementation of this particular interface. abc.Meta is one of the possible approaches for implicit interface implementation in Python. It has alternatives like Duck typing and typing_extensions.Protocol . Yet again, it's nothing wrong with it if you want to design contracts in your codebase using abc.Meta . On the other hand, implementation inheritance was designed for code reuse in its heart. That's where things start to get out of hands. Implementation inheritance breaks encapsulation by its definition. That's why it's easy to end up with code like that: >>> from app import Entity >>> class User ( Entity ): ... database_table = 'users' ... json_fields = [ 'id' , 'name' , 'surname' , 'bio' ] ... permissions = [ 'can_read' , 'can_edit' ] ... query_string_params = [ 'user_*' ] Looking just at that code it's impossible to answer these simple yet important questions: What responsibilities it has? (What it do?) How to use this class? (What public methods does it have?) Everything is hidden from us in the base class. And it has its own base classes as well. You get where it's going. That's why we forbid implementation inheritance. attrs >>> from attr import attrs , attrib >>> from generics import private >>> from app import Entity >>> @private ... @attrs ( frozen = True ) ... class User ( Entity ): ... name = attrib () ... ... def greet ( self ): ... return f 'Hello, { self . name } ' Traceback (most recent call last): ... _generics.exceptions.GenericClassError : Do not use inheritance (use composition instead) dataclasses >>> from dataclasses import dataclass >>> from generics import private >>> from app import Entity >>> @private ... @dataclass ( frozen = True ) ... class User ( Entity ): ... name : str ... ... def greet ( self ): ... return f 'Hello, { self . name } ' Traceback (most recent call last): ... _generics.exceptions.GenericClassError : Do not use inheritance (use composition instead) pydantic >>> from pydantic import BaseModel >>> from generics import private >>> from app import Entity >>> @private ... class User ( Entity , BaseModel ): ... name : str ... ... class Config : ... allow_mutation = False ... ... def greet ( self ): ... return f 'Hello, { self . name } ' Traceback (most recent call last): ... _generics.exceptions.GenericClassError : Do not use inheritance (use composition instead) Note Subtyping inheritance with abc.Meta is not implemented yet. We have plans to implement it in the future. Underscore names are forbidden \u00b6 As we mentioned at the beginning of the document, Python has a convention for private attributes and methods to start with a single underscore ( _ ) character. This harms readability. Thus they are forbidden. The library hides everything properly anyway. The presence of private methods especially is a sign of bad design. That means that the class has too many layers of abstractions hidden in it. The intention to hide methods defined in the class means that they operate on a lower level of abstractions that the responsibility of the class belongs to. Instead of using the composition of objects and encapsulation, the author decides to use uglier names. That gives hope to the author that users will not use methods with ugly names in their code. A bad design indeed. attrs >>> from attr import attrs , attrib >>> from generics import private >>> @private ... @attrs ( frozen = True ) ... class User : ... _name = attrib () ... surname = attrib () ... ... def greet ( self ): ... return f 'Hello, { self . _name } { self . surname } ' Traceback (most recent call last): ... _generics.exceptions.GenericClassError : Do not use private attributes dataclasses >>> from dataclasses import dataclass >>> from generics import private >>> @private ... @dataclass ( frozen = True ) ... class User : ... _name : str ... surname : str ... ... def greet ( self ): ... return f 'Hello, { self . _name } { self . surname } ' Traceback (most recent call last): ... _generics.exceptions.GenericClassError : Do not use private attributes Note This check is not supported if you are using pydantic library due to its limitations. Prefer immutable classes \u00b6 Awoid changing inner state of the classes as much as possible. Way too many problems was caused because of changed data in unexpected parts of code. To deal with such problem we should respect transparency of the references. Always create new name for the new state . Instead of protecting different parts of the code with same conditional statements, make methods of a class return a new instance of the class if it need to change something. Bad : attrs >>> from attr import attrs , attrib >>> from generics import private >>> @private ... @attrs ... class User : ... name = attrib () ... ... def rename ( self , name ): ... self . name = name >>> User ( name = 'Jeff' ) . rename ( 'John' ) dataclasses >>> from dataclasses import dataclass >>> from generics import private >>> @private ... @dataclass ... class User : ... name : str ... ... def rename ( self , name ): ... self . name = name >>> User ( name = 'Jeff' ) . rename ( 'John' ) pydantic >>> from pydantic import BaseModel >>> from generics import private >>> @private ... class User ( BaseModel ): ... name : str ... ... def rename ( self , name ): ... self . name = name >>> User ( name = 'Jeff' ) . rename ( 'John' ) Good : attrs >>> from attr import attrs , attrib , evolve >>> from generics import private >>> @private ... @attrs ... class User : ... name = attrib () ... ... def rename ( self , name ): ... return evolve ( self , name = name ) >>> User ( name = 'Jeff' ) . rename ( 'John' ) User(name='John') dataclasses >>> from dataclasses import dataclass , replace >>> from generics import private >>> @private ... @dataclass ... class User : ... name : str ... ... def rename ( self , name ): ... return replace ( self , name = name ) >>> User ( name = 'Jeff' ) . rename ( 'John' ) User(name='John') \u2014 \u2b50\ufe0f \u2014 The generics library is part of the SOLID python family.","title":"Private"},{"location":"private/#private","text":"","title":"Private"},{"location":"private/#why","text":"Object-oriented programming has a lot of advantages over procedural programming. The one of these advantages is encapsulation of data. In python encapsulation is implemented without information hiding . We lack this feature and want to fix it.","title":"Why"},{"location":"private/#leading-underscores","text":"The naming convention with leading underscores from pep8 does not work the way we want. For example, the code below will not hide class attributes. >>> class User : ... def __init__ ( self , name ): ... self . _name = name ... ... def greet ( self ): ... return f 'Hello, { self . _name } ' >>> user = User ( 'Jeff' ) >>> user . greet () 'Hello, Jeff' >>> user . _name # No information hiding here :( 'Jeff' It may be a nice convention to have it in the code base, but it does not work (it does not make architecture any better) it harms readability (underscores are ugly)","title":"Leading underscores"},{"location":"private/#principles","text":"All methods are public All attributes are private and hidden Static methods are forbidden Class methods should return instances At least one instance method is required At least one encapsulated attribute is required Implementation inheritance is forbidden Underscore names are forbidden Prefer immutable classes","title":"Principles"},{"location":"private/#all-methods-are-public","text":"The main purpose of objects in object-oriented programming is in behavior they could provide to the client code. Behavior intended by object could be expressed with its methods. Thus every instance and class method of the object is public. Class should be decorated with @private function. attrs >>> from attr import attrs , attrib >>> from generics import private >>> @private ... @attrs ( frozen = True ) ... class User : ... name = attrib () ... ... def greet ( self ): ... return f 'Hello, { self . name } ' >>> User Private(User) >>> user = User ( 'Jeff' ) >>> user Private(User(name='Jeff')) >>> user . greet () 'Hello, Jeff' dataclasses >>> from dataclasses import dataclass >>> from generics import private >>> @private ... @dataclass ( frozen = True ) ... class User : ... name : str ... ... def greet ( self ): ... return f 'Hello, { self . name } ' >>> User Private(User) >>> user = User ( 'Jeff' ) >>> user Private(User(name='Jeff')) >>> user . greet () 'Hello, Jeff' pydantic >>> from pydantic import BaseModel >>> from generics import private >>> @private ... class User ( BaseModel ): ... name : str ... ... class Config : ... allow_mutation = False ... ... def greet ( self ): ... return f 'Hello, { self . name } ' >>> User Private(User) >>> user = User ( name = 'Jeff' ) >>> user Private(User(name='Jeff')) >>> user . greet () 'Hello, Jeff'","title":"All methods are public"},{"location":"private/#all-attributes-are-private-and-hidden","text":"The main advantage of objects in object-oriented programming is in encapsulation and information hiding . Procedural programming have a lot of problems related to coupling. All data flows directly through the execution flow. Every part of the code in this flow is highly coupled with each other because of the data they pass to each other. In opposite in the object-oriented programming we put parts of the data close to the parts of the code where it'll be used. Thus the execution flow sees only method calls. Client code does not know what data were encapsulated inside the object. And it's none of its business. Thus all attributes encapsulated inside the objects are private. The constructor is the only place where you can put anything inside the object. Own methods of the object (defined in its class) are free to use its attributes as usual. Attribute access in the client code will raise an exception. >>> user . name Traceback (most recent call last): ... AttributeError : 'Private(User)' object has no attribute 'name'","title":"All attributes are private and hidden"},{"location":"private/#static-methods-are-forbidden","text":"Good objects expose their behavior and hide their state. The behavior objects expose should be related to the state object hides. This metric is called cohesion. Static methods can't access the inner state of the object. That's why the behavior they expose doesn't relate to the object. Cohesion will go down. That's why we forbid static methods. If you need such behavior, put it outside of the class. If this behavior is neccessary in the instance method of the original class, encapsulate it. Pass that new thing to the constructor and access it in methods. attrs >>> from attr import attrs , attrib >>> from generics import private >>> @private ... @attrs ( frozen = True ) ... class User : ... name = attrib () ... ... def greet ( self ): ... return f 'Hello, { self . name } ' ... ... @staticmethod ... def is_bot (): ... return False Traceback (most recent call last): ... _generics.exceptions.GenericClassError : Do not use static methods (use composition instead) dataclasses >>> from dataclasses import dataclass >>> from generics import private >>> @private ... @dataclass ( frozen = True ) ... class User : ... name : str ... ... def greet ( self ): ... return f 'Hello, { self . name } ' ... ... @staticmethod ... def is_bot (): ... return False Traceback (most recent call last): ... _generics.exceptions.GenericClassError : Do not use static methods (use composition instead) pydantic >>> from pydantic import BaseModel >>> from generics import private >>> @private ... class User ( BaseModel ): ... name : str ... ... class Config : ... allow_mutation = False ... ... def greet ( self ): ... return f 'Hello, { self . name } ' ... ... @staticmethod ... def is_bot (): ... return False Traceback (most recent call last): ... _generics.exceptions.GenericClassError : Do not use static methods (use composition instead)","title":"Static methods are forbidden"},{"location":"private/#class-methods-should-return-instances","text":"As we mentioned earlier, objects should expose behavior. Class methods do not have access to any kind of inner state sinse there is no object encapsulating it. Thus the only kind of behavior class method should be able to do is instantiation of the object. attrs >>> from attr import attrs , attrib >>> from generics import private >>> @private ... @attrs ( frozen = True ) ... class User : ... name = attrib () ... ... def greet ( self ): ... return f 'Hello, { self . name } ' ... ... @classmethod ... def create ( cls ): ... pass >>> User . create () Traceback (most recent call last): ... _generics.exceptions.GenericInstanceError : 'create' classmethod should return an instance of the 'User' class dataclasses >>> from dataclasses import dataclass >>> from generics import private >>> @private ... @dataclass ( frozen = True ) ... class User : ... name : str ... ... def greet ( self ): ... return f 'Hello, { self . name } ' ... ... @classmethod ... def create ( cls ): ... pass >>> User . create () Traceback (most recent call last): ... _generics.exceptions.GenericInstanceError : 'create' classmethod should return an instance of the 'User' class pydantic >>> from pydantic import BaseModel >>> from generics import private >>> @private ... class User ( BaseModel ): ... name : str ... ... class Config : ... allow_mutation = False ... ... def greet ( self ): ... return f 'Hello, { self . name } ' ... ... @classmethod ... def create ( cls ): ... pass >>> User . create () Traceback (most recent call last): ... _generics.exceptions.GenericInstanceError : 'create' classmethod should return an instance of the 'User' class","title":"Class methods should return instances"},{"location":"private/#at-least-one-instance-method-is-required","text":"As we mention a couple of times earlier the main goal of the good objects is to expose behavior. If there is no methods defined on the class, it's not possible to expose any kind of behavior. The object becomes useless. Class methods does not count since it has a different purpose. attrs >>> from attr import attrs , attrib >>> from generics import private >>> @private ... @attrs ( frozen = True ) ... class User : ... name = attrib () ... ... @classmethod ... def create ( cls ): ... pass Traceback (most recent call last): ... _generics.exceptions.GenericClassError : Define at least one instance method dataclasses >>> from dataclasses import dataclass >>> from generics import private >>> @private ... @dataclass ( frozen = True ) ... class User : ... name : str ... ... @classmethod ... def create ( cls ): ... pass Traceback (most recent call last): ... _generics.exceptions.GenericClassError : Define at least one instance method pydantic >>> from pydantic import BaseModel >>> from generics import private >>> @private ... class User ( BaseModel ): ... name : str ... ... class Config : ... allow_mutation = False ... ... @classmethod ... def create ( cls ): ... pass Traceback (most recent call last): ... _generics.exceptions.GenericClassError : Define at least one instance method","title":"At least one instance method is required"},{"location":"private/#at-least-one-encapsulated-attribute-is-required","text":"The same as a previous one this rules exists because of the encapsulation restrictions. If your object does not encapsulate at least one attribute, it does not have any state. In that case behavior exposed by the object does not relate to the object itself. Thus there is no reason to define such kind of method on the class in the first place. attrs >>> from attr import attrs , attrib >>> from generics import private >>> @private ... @attrs ( frozen = True ) ... class User : ... ... def greet ( self ): ... return 'Hello, Jeff' Traceback (most recent call last): ... _generics.exceptions.GenericClassError : Define at least one encapsulated attribute dataclasses >>> from dataclasses import dataclass >>> from generics import private >>> @private ... @dataclass ( frozen = True ) ... class User : ... ... def greet ( self ): ... return 'Hello, Jeff' Traceback (most recent call last): ... _generics.exceptions.GenericClassError : Define at least one encapsulated attribute pydantic >>> from pydantic import BaseModel >>> from generics import private >>> @private ... class User ( BaseModel ): ... ... def greet ( self ): ... return 'Hello, Jeff' Traceback (most recent call last): ... _generics.exceptions.GenericClassError : Define at least one encapsulated attribute","title":"At least one encapsulated attribute is required"},{"location":"private/#implementation-inheritance-is-forbidden","text":"First of all, there are two types of inheritance - subtyping inheritance and implementation inheritance . It's nothing wrong with subtyping inheritance. It's used to create \"is a\" relationship between classes. It's a technique where you can say that this class is an implementation of this particular interface. abc.Meta is one of the possible approaches for implicit interface implementation in Python. It has alternatives like Duck typing and typing_extensions.Protocol . Yet again, it's nothing wrong with it if you want to design contracts in your codebase using abc.Meta . On the other hand, implementation inheritance was designed for code reuse in its heart. That's where things start to get out of hands. Implementation inheritance breaks encapsulation by its definition. That's why it's easy to end up with code like that: >>> from app import Entity >>> class User ( Entity ): ... database_table = 'users' ... json_fields = [ 'id' , 'name' , 'surname' , 'bio' ] ... permissions = [ 'can_read' , 'can_edit' ] ... query_string_params = [ 'user_*' ] Looking just at that code it's impossible to answer these simple yet important questions: What responsibilities it has? (What it do?) How to use this class? (What public methods does it have?) Everything is hidden from us in the base class. And it has its own base classes as well. You get where it's going. That's why we forbid implementation inheritance. attrs >>> from attr import attrs , attrib >>> from generics import private >>> from app import Entity >>> @private ... @attrs ( frozen = True ) ... class User ( Entity ): ... name = attrib () ... ... def greet ( self ): ... return f 'Hello, { self . name } ' Traceback (most recent call last): ... _generics.exceptions.GenericClassError : Do not use inheritance (use composition instead) dataclasses >>> from dataclasses import dataclass >>> from generics import private >>> from app import Entity >>> @private ... @dataclass ( frozen = True ) ... class User ( Entity ): ... name : str ... ... def greet ( self ): ... return f 'Hello, { self . name } ' Traceback (most recent call last): ... _generics.exceptions.GenericClassError : Do not use inheritance (use composition instead) pydantic >>> from pydantic import BaseModel >>> from generics import private >>> from app import Entity >>> @private ... class User ( Entity , BaseModel ): ... name : str ... ... class Config : ... allow_mutation = False ... ... def greet ( self ): ... return f 'Hello, { self . name } ' Traceback (most recent call last): ... _generics.exceptions.GenericClassError : Do not use inheritance (use composition instead) Note Subtyping inheritance with abc.Meta is not implemented yet. We have plans to implement it in the future.","title":"Implementation inheritance is forbidden"},{"location":"private/#underscore-names-are-forbidden","text":"As we mentioned at the beginning of the document, Python has a convention for private attributes and methods to start with a single underscore ( _ ) character. This harms readability. Thus they are forbidden. The library hides everything properly anyway. The presence of private methods especially is a sign of bad design. That means that the class has too many layers of abstractions hidden in it. The intention to hide methods defined in the class means that they operate on a lower level of abstractions that the responsibility of the class belongs to. Instead of using the composition of objects and encapsulation, the author decides to use uglier names. That gives hope to the author that users will not use methods with ugly names in their code. A bad design indeed. attrs >>> from attr import attrs , attrib >>> from generics import private >>> @private ... @attrs ( frozen = True ) ... class User : ... _name = attrib () ... surname = attrib () ... ... def greet ( self ): ... return f 'Hello, { self . _name } { self . surname } ' Traceback (most recent call last): ... _generics.exceptions.GenericClassError : Do not use private attributes dataclasses >>> from dataclasses import dataclass >>> from generics import private >>> @private ... @dataclass ( frozen = True ) ... class User : ... _name : str ... surname : str ... ... def greet ( self ): ... return f 'Hello, { self . _name } { self . surname } ' Traceback (most recent call last): ... _generics.exceptions.GenericClassError : Do not use private attributes Note This check is not supported if you are using pydantic library due to its limitations.","title":"Underscore names are forbidden"},{"location":"private/#prefer-immutable-classes","text":"Awoid changing inner state of the classes as much as possible. Way too many problems was caused because of changed data in unexpected parts of code. To deal with such problem we should respect transparency of the references. Always create new name for the new state . Instead of protecting different parts of the code with same conditional statements, make methods of a class return a new instance of the class if it need to change something. Bad : attrs >>> from attr import attrs , attrib >>> from generics import private >>> @private ... @attrs ... class User : ... name = attrib () ... ... def rename ( self , name ): ... self . name = name >>> User ( name = 'Jeff' ) . rename ( 'John' ) dataclasses >>> from dataclasses import dataclass >>> from generics import private >>> @private ... @dataclass ... class User : ... name : str ... ... def rename ( self , name ): ... self . name = name >>> User ( name = 'Jeff' ) . rename ( 'John' ) pydantic >>> from pydantic import BaseModel >>> from generics import private >>> @private ... class User ( BaseModel ): ... name : str ... ... def rename ( self , name ): ... self . name = name >>> User ( name = 'Jeff' ) . rename ( 'John' ) Good : attrs >>> from attr import attrs , attrib , evolve >>> from generics import private >>> @private ... @attrs ... class User : ... name = attrib () ... ... def rename ( self , name ): ... return evolve ( self , name = name ) >>> User ( name = 'Jeff' ) . rename ( 'John' ) User(name='John') dataclasses >>> from dataclasses import dataclass , replace >>> from generics import private >>> @private ... @dataclass ... class User : ... name : str ... ... def rename ( self , name ): ... return replace ( self , name = name ) >>> User ( name = 'Jeff' ) . rename ( 'John' ) User(name='John') \u2014 \u2b50\ufe0f \u2014 The generics library is part of the SOLID python family.","title":"Prefer immutable classes"}]}