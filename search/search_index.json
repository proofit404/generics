{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Generics \u00b6 A classy toolkit designed with OOP in mind. Documentation | Source Code | Task Tracker In our opinion, main benefits of having objects implemented in the language are encapsulation and polymorphous. Classes that could be easily used in a composition are tricky to write. The generics library aims to help you in writing code with high quality. Pros \u00b6 Real private attributes without loosing the readability Leads to a better design forcing you to use encapsulation properly Makes writing quality code with high cohesion and low coupling easier Guides you to follow SOLID principles Example \u00b6 The generics library gives you an easy way to define private attributes on objects without loosing little nice things like readability. >>> from attr import attrs , attrib >>> from generics import private >>> @private ... @attrs ( frozen = True ) ... class User : ... name = attrib () ... ... def greet ( self ): ... return f 'Hello, { self . name } ' >>> user = User ( 'Jeff' ) >>> user . greet () 'Hello, Jeff' >>> hasattr ( user , 'name' ) False Questions \u00b6 If you have any questions, feel free to create an issue in our Task Tracker . We have the question label exactly for this purpose. License \u00b6 Generics library is offered under the two clause BSD license. \u2014 \u2b50\ufe0f \u2014 The generics library is part of the SOLID python family.","title":"Home"},{"location":"#generics","text":"A classy toolkit designed with OOP in mind. Documentation | Source Code | Task Tracker In our opinion, main benefits of having objects implemented in the language are encapsulation and polymorphous. Classes that could be easily used in a composition are tricky to write. The generics library aims to help you in writing code with high quality.","title":"Generics"},{"location":"#pros","text":"Real private attributes without loosing the readability Leads to a better design forcing you to use encapsulation properly Makes writing quality code with high cohesion and low coupling easier Guides you to follow SOLID principles","title":"Pros"},{"location":"#example","text":"The generics library gives you an easy way to define private attributes on objects without loosing little nice things like readability. >>> from attr import attrs , attrib >>> from generics import private >>> @private ... @attrs ( frozen = True ) ... class User : ... name = attrib () ... ... def greet ( self ): ... return f 'Hello, { self . name } ' >>> user = User ( 'Jeff' ) >>> user . greet () 'Hello, Jeff' >>> hasattr ( user , 'name' ) False","title":"Example"},{"location":"#questions","text":"If you have any questions, feel free to create an issue in our Task Tracker . We have the question label exactly for this purpose.","title":"Questions"},{"location":"#license","text":"Generics library is offered under the two clause BSD license. \u2014 \u2b50\ufe0f \u2014 The generics library is part of the SOLID python family.","title":"License"},{"location":"changelog/","text":"1.0.0 (2020-07-03) \u00b6 Features \u00b6 implement @private decorator ( 1d237eb ) \u2014 \u2b50\ufe0f \u2014 The generics library is part of the SOLID python family.","title":"Changelog"},{"location":"changelog/#100-2020-07-03","text":"","title":"1.0.0 (2020-07-03)"},{"location":"changelog/#features","text":"implement @private decorator ( 1d237eb ) \u2014 \u2b50\ufe0f \u2014 The generics library is part of the SOLID python family.","title":"Features"},{"location":"installation/","text":"Installation \u00b6 The generics library is available on PyPI. To install it run: pip install generics We use semantic release to publish packages as soon as pull requests land to the master branch. It's not necessary to use develompment version of the library. \u2014 \u2b50\ufe0f \u2014 The generics library is part of the SOLID python family.","title":"Installation"},{"location":"installation/#installation","text":"The generics library is available on PyPI. To install it run: pip install generics We use semantic release to publish packages as soon as pull requests land to the master branch. It's not necessary to use develompment version of the library. \u2014 \u2b50\ufe0f \u2014 The generics library is part of the SOLID python family.","title":"Installation"},{"location":"private/","text":"Private \u00b6 Why \u00b6 Object-oriented programming has a lot of advantages over procedural programming. The one of these advantages is encapsulation of data. In python encapsulation is implemented without information hiding . We lack this feature and want to fix it. Leading underscores \u00b6 The naming convention with leading underscores from pep8 does not work the way we want. For example, the code below will not hide class attributes. >>> class User : ... def __init__ ( self , name ): ... self . _name = name ... ... def greet ( self ): ... return f 'Hello, { self . _name } ' >>> user = User ( 'Jeff' ) >>> user . greet () 'Hello, Jeff' >>> user . _name # No information hiding here :( 'Jeff' It may be a nice convention to have it in the code base, but it does not work (it does not make architecture any better) it harms readability (underscores are ugly) Principles \u00b6 All methods are public All attributes are private and hidden Static methods are forbidden All methods are public \u00b6 The main purpose of objects in object-oriented programming is in behavior they could provide to the client code. Behavior intended by object could be expressed with its methods. Thus every instance and class method of the object is public. Class should be decorated with @private function. attrs >>> from attr import attrs , attrib >>> from generics import private >>> @private ... @attrs ( frozen = True ) ... class User : ... name = attrib () ... ... def greet ( self ): ... return f 'Hello, { self . name } ' >>> User Private ( User ) >>> user = User ( 'Jeff' ) >>> user Private ( User ( name = 'Jeff' )) >>> user . greet () 'Hello, Jeff' dataclasses >>> from dataclasses import dataclass >>> from generics import private >>> @private ... @dataclass ( frozen = True ) ... class User : ... name : str ... ... def greet ( self ): ... return f 'Hello, { self . name } ' >>> User Private ( User ) >>> user = User ( 'Jeff' ) >>> user Private ( User ( name = 'Jeff' )) >>> user . greet () 'Hello, Jeff' pydantic >>> from pydantic import BaseModel >>> from generics import private >>> @private ... class User ( BaseModel ): ... name : str ... ... class Config : ... allow_mutation = False ... ... def greet ( self ): ... return f 'Hello, { self . name } ' >>> User Private ( User ) >>> user = User ( name = 'Jeff' ) >>> user Private ( User ( name = 'Jeff' )) >>> user . greet () 'Hello, Jeff' All attributes are private and hidden \u00b6 The main advantage of objects in object-oriented programming is in encapsulation and information hiding . Procedural programming have a lot of problems related to coupling. All data flows directly through the execution flow. Every part of the code in this flow is highly coupled with each other because of the data they pass to each other. In opposite in the object-oriented programming we put parts of the data close to the parts of the code where it'll be used. Thus the execution flow sees only method calls. Client code does not know what data were encapsulated inside the object. And it's none of its business. Thus all attributes encapsulated inside the objects are private. The constructor is the only place where you can put anything inside the object. Own methods of the object (defined in its class) are free to use its attributes as usual. Attribute access in the client code will raise an exception. >>> user . name Traceback ( most recent call last ): ... AttributeError : 'Private(User)' object has no attribute 'name' Static methods are forbidden \u00b6 Good objects expose their behavior and hide their state. The behavior objects expose should be related to the state object hides. This metric is called cohesion. Static methods can't access the inner state of the object. That's why the behavior they expose doesn't relate to the object. Cohesion will go down. That's why we forbid static methods. If you need such behavior, put it outside of the class and encapsulate it. attrs >>> from attr import attrs , attrib >>> from generics import private >>> @private ... @attrs ( frozen = True ) ... class User : ... name = attrib () ... ... def greet ( self ): ... return f 'Hello, { self . name } ' ... ... @staticmethod ... def is_bot (): ... return False Traceback ( most recent call last ): ... _generics . exceptions . GenericClassError : Do not use static methods ( use composition instead ) dataclasses >>> from dataclasses import dataclass >>> from generics import private >>> @private ... @dataclass ( frozen = True ) ... class User : ... name : str ... ... def greet ( self ): ... return f 'Hello, { self . name } ' ... ... @staticmethod ... def is_bot (): ... return False Traceback ( most recent call last ): ... _generics . exceptions . GenericClassError : Do not use static methods ( use composition instead ) pydantic >>> from pydantic import BaseModel >>> from generics import private >>> @private ... class User ( BaseModel ): ... name : str ... ... class Config : ... allow_mutation = False ... ... def greet ( self ): ... return f 'Hello, { self . name } ' ... ... @staticmethod ... def is_bot (): ... return False Traceback ( most recent call last ): ... _generics . exceptions . GenericClassError : Do not use static methods ( use composition instead ) \u2014 \u2b50\ufe0f \u2014 The generics library is part of the SOLID python family.","title":"Private"},{"location":"private/#private","text":"","title":"Private"},{"location":"private/#why","text":"Object-oriented programming has a lot of advantages over procedural programming. The one of these advantages is encapsulation of data. In python encapsulation is implemented without information hiding . We lack this feature and want to fix it.","title":"Why"},{"location":"private/#leading-underscores","text":"The naming convention with leading underscores from pep8 does not work the way we want. For example, the code below will not hide class attributes. >>> class User : ... def __init__ ( self , name ): ... self . _name = name ... ... def greet ( self ): ... return f 'Hello, { self . _name } ' >>> user = User ( 'Jeff' ) >>> user . greet () 'Hello, Jeff' >>> user . _name # No information hiding here :( 'Jeff' It may be a nice convention to have it in the code base, but it does not work (it does not make architecture any better) it harms readability (underscores are ugly)","title":"Leading underscores"},{"location":"private/#principles","text":"All methods are public All attributes are private and hidden Static methods are forbidden","title":"Principles"},{"location":"private/#all-methods-are-public","text":"The main purpose of objects in object-oriented programming is in behavior they could provide to the client code. Behavior intended by object could be expressed with its methods. Thus every instance and class method of the object is public. Class should be decorated with @private function. attrs >>> from attr import attrs , attrib >>> from generics import private >>> @private ... @attrs ( frozen = True ) ... class User : ... name = attrib () ... ... def greet ( self ): ... return f 'Hello, { self . name } ' >>> User Private ( User ) >>> user = User ( 'Jeff' ) >>> user Private ( User ( name = 'Jeff' )) >>> user . greet () 'Hello, Jeff' dataclasses >>> from dataclasses import dataclass >>> from generics import private >>> @private ... @dataclass ( frozen = True ) ... class User : ... name : str ... ... def greet ( self ): ... return f 'Hello, { self . name } ' >>> User Private ( User ) >>> user = User ( 'Jeff' ) >>> user Private ( User ( name = 'Jeff' )) >>> user . greet () 'Hello, Jeff' pydantic >>> from pydantic import BaseModel >>> from generics import private >>> @private ... class User ( BaseModel ): ... name : str ... ... class Config : ... allow_mutation = False ... ... def greet ( self ): ... return f 'Hello, { self . name } ' >>> User Private ( User ) >>> user = User ( name = 'Jeff' ) >>> user Private ( User ( name = 'Jeff' )) >>> user . greet () 'Hello, Jeff'","title":"All methods are public"},{"location":"private/#all-attributes-are-private-and-hidden","text":"The main advantage of objects in object-oriented programming is in encapsulation and information hiding . Procedural programming have a lot of problems related to coupling. All data flows directly through the execution flow. Every part of the code in this flow is highly coupled with each other because of the data they pass to each other. In opposite in the object-oriented programming we put parts of the data close to the parts of the code where it'll be used. Thus the execution flow sees only method calls. Client code does not know what data were encapsulated inside the object. And it's none of its business. Thus all attributes encapsulated inside the objects are private. The constructor is the only place where you can put anything inside the object. Own methods of the object (defined in its class) are free to use its attributes as usual. Attribute access in the client code will raise an exception. >>> user . name Traceback ( most recent call last ): ... AttributeError : 'Private(User)' object has no attribute 'name'","title":"All attributes are private and hidden"},{"location":"private/#static-methods-are-forbidden","text":"Good objects expose their behavior and hide their state. The behavior objects expose should be related to the state object hides. This metric is called cohesion. Static methods can't access the inner state of the object. That's why the behavior they expose doesn't relate to the object. Cohesion will go down. That's why we forbid static methods. If you need such behavior, put it outside of the class and encapsulate it. attrs >>> from attr import attrs , attrib >>> from generics import private >>> @private ... @attrs ( frozen = True ) ... class User : ... name = attrib () ... ... def greet ( self ): ... return f 'Hello, { self . name } ' ... ... @staticmethod ... def is_bot (): ... return False Traceback ( most recent call last ): ... _generics . exceptions . GenericClassError : Do not use static methods ( use composition instead ) dataclasses >>> from dataclasses import dataclass >>> from generics import private >>> @private ... @dataclass ( frozen = True ) ... class User : ... name : str ... ... def greet ( self ): ... return f 'Hello, { self . name } ' ... ... @staticmethod ... def is_bot (): ... return False Traceback ( most recent call last ): ... _generics . exceptions . GenericClassError : Do not use static methods ( use composition instead ) pydantic >>> from pydantic import BaseModel >>> from generics import private >>> @private ... class User ( BaseModel ): ... name : str ... ... class Config : ... allow_mutation = False ... ... def greet ( self ): ... return f 'Hello, { self . name } ' ... ... @staticmethod ... def is_bot (): ... return False Traceback ( most recent call last ): ... _generics . exceptions . GenericClassError : Do not use static methods ( use composition instead ) \u2014 \u2b50\ufe0f \u2014 The generics library is part of the SOLID python family.","title":"Static methods are forbidden"}]}