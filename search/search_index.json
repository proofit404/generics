{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Generics \u00b6 A classy toolkit designed with OOP in mind. Documentation | Source Code | Task Tracker In our opinion, main benefits of having objects implemented in the language are encapsulation and polymorphous. Classes that could be easily used in a composition are tricky to write. The generics library aims to help you in writing code with high quality. Pros \u00b6 Real private attributes without loosing the readability Leads to a better design forcing you to use encapsulation properly Makes writing quality code with high cohesion and low coupling easier Guides you to follow SOLID principles Example \u00b6 The generics library gives you an easy way to define private attributes on objects without loosing little nice things like readability. >>> from generics import private >>> @private ... class User : ... def __init__ ( self , name ): ... self . name = name ... ... def greet ( self ): ... return f \"Hello, { self . name } \" >>> user = User ( \"Jeff\" ) >>> user . greet () 'Hello, Jeff' >>> hasattr ( user , \"name\" ) False Questions \u00b6 If you have any questions, feel free to create an issue in our Task Tracker . We have the question label exactly for this purpose. Enterprise support \u00b6 If you have an issue with any version of the library, you can apply for a paid enterprise support contract. This will guarantee you that no breaking changes will happen to you. No matter how old version you're using at the moment. All necessary features and bug fixes will be backported in a way that serves your needs. Please contact proofit404@gmail.com if you're interested in it. License \u00b6 generics library is offered under the two clause BSD license. \u2014 \u2b50 \u2014 The generics library is part of the SOLID python family.","title":"Home"},{"location":"#generics","text":"A classy toolkit designed with OOP in mind. Documentation | Source Code | Task Tracker In our opinion, main benefits of having objects implemented in the language are encapsulation and polymorphous. Classes that could be easily used in a composition are tricky to write. The generics library aims to help you in writing code with high quality.","title":"Generics"},{"location":"#pros","text":"Real private attributes without loosing the readability Leads to a better design forcing you to use encapsulation properly Makes writing quality code with high cohesion and low coupling easier Guides you to follow SOLID principles","title":"Pros"},{"location":"#example","text":"The generics library gives you an easy way to define private attributes on objects without loosing little nice things like readability. >>> from generics import private >>> @private ... class User : ... def __init__ ( self , name ): ... self . name = name ... ... def greet ( self ): ... return f \"Hello, { self . name } \" >>> user = User ( \"Jeff\" ) >>> user . greet () 'Hello, Jeff' >>> hasattr ( user , \"name\" ) False","title":"Example"},{"location":"#questions","text":"If you have any questions, feel free to create an issue in our Task Tracker . We have the question label exactly for this purpose.","title":"Questions"},{"location":"#enterprise-support","text":"If you have an issue with any version of the library, you can apply for a paid enterprise support contract. This will guarantee you that no breaking changes will happen to you. No matter how old version you're using at the moment. All necessary features and bug fixes will be backported in a way that serves your needs. Please contact proofit404@gmail.com if you're interested in it.","title":"Enterprise support"},{"location":"#license","text":"generics library is offered under the two clause BSD license. \u2014 \u2b50 \u2014 The generics library is part of the SOLID python family.","title":"License"},{"location":"attrs/","text":"Attrs \u00b6 attrs is a well known library to define classes in a nicer & shorter way. generics library works out of the box with attrs . As with all previous examples we advice you to make your instances immutable. attrs library has a first class support for immutability. Enable frozen setting on class and use evolve function to copy instancies of it. >>> from attr import attrs , attrib , evolve >>> from generics import private >>> @private ... @attrs ( frozen = True ) ... class User : ... name = attrib () ... ... def greet ( self ): ... return f \"Hello, { self . name } \" ... ... def rename ( self , name ): ... return evolve ( self , name = name ) >>> User Private(User) >>> user = User ( \"Jeff\" ) >>> user Private(User(name='Jeff')) >>> user . greet () 'Hello, Jeff' >>> user . rename ( \"Kate\" ) User(name='Kate') \u2014 \u2b50 \u2014 The generics library is part of the SOLID python family.","title":"Attrs"},{"location":"attrs/#attrs","text":"attrs is a well known library to define classes in a nicer & shorter way. generics library works out of the box with attrs . As with all previous examples we advice you to make your instances immutable. attrs library has a first class support for immutability. Enable frozen setting on class and use evolve function to copy instancies of it. >>> from attr import attrs , attrib , evolve >>> from generics import private >>> @private ... @attrs ( frozen = True ) ... class User : ... name = attrib () ... ... def greet ( self ): ... return f \"Hello, { self . name } \" ... ... def rename ( self , name ): ... return evolve ( self , name = name ) >>> User Private(User) >>> user = User ( \"Jeff\" ) >>> user Private(User(name='Jeff')) >>> user . greet () 'Hello, Jeff' >>> user . rename ( \"Kate\" ) User(name='Kate') \u2014 \u2b50 \u2014 The generics library is part of the SOLID python family.","title":"Attrs"},{"location":"changelog/","text":"3.3.1 (2021-04-07) \u00b6 Bug Fixes \u00b6 ignore dunder class methods #223 ( b72d7ee ) 3.3.0 (2021-02-17) \u00b6 Features \u00b6 deny to call class methods on instances #220 ( 9614030 ) 3.2.1 (2021-01-08) \u00b6 Bug Fixes \u00b6 allow private methods defined globally #215 ( 432abd3 ) 3.2.0 (2021-01-06) \u00b6 Features \u00b6 rewrite without third-party libraries #200 ( 9abd18c ) 3.1.0 (2020-11-20) \u00b6 Features \u00b6 support pypy interpreter #9 ( 0045024 ) 3.0.0 (2020-11-12) \u00b6 Build System \u00b6 add python 3.9 support #186 ( 70b39dd ) BREAKING CHANGES \u00b6 drop python 3.6 support. 2.0.0 (2020-08-30) \u00b6 Code Refactoring \u00b6 drop Python 2.7 and 3.4 support #134 ( 8cbbcfb ) BREAKING CHANGES \u00b6 Due to the our new policy of enterprise user support we will drop abandoned version of python and libraries we are integrated with as soon as they reach official end of life. 1.1.0 (2020-08-21) \u00b6 Features \u00b6 support dependencies library ( 7614944 ) 1.0.1 (2020-08-06) \u00b6 Bug Fixes \u00b6 fake @defended and @delegated decorators ( 2ae14e3 ) 1.0.0 (2020-07-03) \u00b6 Features \u00b6 implement @private decorator ( 1d237eb ) \u2014 \u2b50 \u2014 The generics library is part of the SOLID python family.","title":"Changelog"},{"location":"changelog/#331-2021-04-07","text":"","title":"3.3.1 (2021-04-07)"},{"location":"changelog/#bug-fixes","text":"ignore dunder class methods #223 ( b72d7ee )","title":"Bug Fixes"},{"location":"changelog/#330-2021-02-17","text":"","title":"3.3.0 (2021-02-17)"},{"location":"changelog/#features","text":"deny to call class methods on instances #220 ( 9614030 )","title":"Features"},{"location":"changelog/#321-2021-01-08","text":"","title":"3.2.1 (2021-01-08)"},{"location":"changelog/#bug-fixes_1","text":"allow private methods defined globally #215 ( 432abd3 )","title":"Bug Fixes"},{"location":"changelog/#320-2021-01-06","text":"","title":"3.2.0 (2021-01-06)"},{"location":"changelog/#features_1","text":"rewrite without third-party libraries #200 ( 9abd18c )","title":"Features"},{"location":"changelog/#310-2020-11-20","text":"","title":"3.1.0 (2020-11-20)"},{"location":"changelog/#features_2","text":"support pypy interpreter #9 ( 0045024 )","title":"Features"},{"location":"changelog/#300-2020-11-12","text":"","title":"3.0.0 (2020-11-12)"},{"location":"changelog/#build-system","text":"add python 3.9 support #186 ( 70b39dd )","title":"Build System"},{"location":"changelog/#breaking-changes","text":"drop python 3.6 support.","title":"BREAKING CHANGES"},{"location":"changelog/#200-2020-08-30","text":"","title":"2.0.0 (2020-08-30)"},{"location":"changelog/#code-refactoring","text":"drop Python 2.7 and 3.4 support #134 ( 8cbbcfb )","title":"Code Refactoring"},{"location":"changelog/#breaking-changes_1","text":"Due to the our new policy of enterprise user support we will drop abandoned version of python and libraries we are integrated with as soon as they reach official end of life.","title":"BREAKING CHANGES"},{"location":"changelog/#110-2020-08-21","text":"","title":"1.1.0 (2020-08-21)"},{"location":"changelog/#features_3","text":"support dependencies library ( 7614944 )","title":"Features"},{"location":"changelog/#101-2020-08-06","text":"","title":"1.0.1 (2020-08-06)"},{"location":"changelog/#bug-fixes_2","text":"fake @defended and @delegated decorators ( 2ae14e3 )","title":"Bug Fixes"},{"location":"changelog/#100-2020-07-03","text":"","title":"1.0.0 (2020-07-03)"},{"location":"changelog/#features_4","text":"implement @private decorator ( 1d237eb ) \u2014 \u2b50 \u2014 The generics library is part of the SOLID python family.","title":"Features"},{"location":"dataclasses/","text":"Dataclasses \u00b6 dataclasses is a simpler alternative to attrs from python standard library. generics works with it out of the box. As with all previous examples we advice you to make your instances immutable. dataclasses library has a first class support for immutability. Enable frozen setting on class and use replace function to copy instancies of it. >>> from dataclasses import dataclass , replace >>> from generics import private >>> @private ... @dataclass ( frozen = True ) ... class User : ... name : str ... ... def greet ( self ): ... return f \"Hello, { self . name } \" ... ... def rename ( self , name ): ... return replace ( self , name = name ) >>> User Private(User) >>> user = User ( \"Jeff\" ) >>> user Private(User(name='Jeff')) >>> user . greet () 'Hello, Jeff' >>> user . rename ( \"Kate\" ) User(name='Kate') \u2014 \u2b50 \u2014 The generics library is part of the SOLID python family.","title":"Dataclasses"},{"location":"dataclasses/#dataclasses","text":"dataclasses is a simpler alternative to attrs from python standard library. generics works with it out of the box. As with all previous examples we advice you to make your instances immutable. dataclasses library has a first class support for immutability. Enable frozen setting on class and use replace function to copy instancies of it. >>> from dataclasses import dataclass , replace >>> from generics import private >>> @private ... @dataclass ( frozen = True ) ... class User : ... name : str ... ... def greet ( self ): ... return f \"Hello, { self . name } \" ... ... def rename ( self , name ): ... return replace ( self , name = name ) >>> User Private(User) >>> user = User ( \"Jeff\" ) >>> user Private(User(name='Jeff')) >>> user . greet () 'Hello, Jeff' >>> user . rename ( \"Kate\" ) User(name='Kate') \u2014 \u2b50 \u2014 The generics library is part of the SOLID python family.","title":"Dataclasses"},{"location":"dependencies/","text":"Dependencies \u00b6 It is possible to instantiate classes decorated with @private function via dependencies library. >>> from dependencies import Injector >>> from generics import private >>> @private ... class User : ... def __init__ ( self , name ): ... self . name = name ... ... def greet ( self ): ... return f \"Hello, { self . name } \" >>> class UserContainer ( Injector ): ... user = User ... name = \"Jeff\" >>> UserContainer . user . greet () 'Hello, Jeff' \u2014 \u2b50 \u2014 The generics library is part of the SOLID python family.","title":"Dependencies"},{"location":"dependencies/#dependencies","text":"It is possible to instantiate classes decorated with @private function via dependencies library. >>> from dependencies import Injector >>> from generics import private >>> @private ... class User : ... def __init__ ( self , name ): ... self . name = name ... ... def greet ( self ): ... return f \"Hello, { self . name } \" >>> class UserContainer ( Injector ): ... user = User ... name = \"Jeff\" >>> UserContainer . user . greet () 'Hello, Jeff' \u2014 \u2b50 \u2014 The generics library is part of the SOLID python family.","title":"Dependencies"},{"location":"installation/","text":"Installation \u00b6 The generics library is available on PyPI. To install it run: pip install -U generics We use semantic release to publish packages as soon as pull requests land to the master branch. It's not necessary to use develompment version of the library. We officially support three last minor releases of CPython interpreter and last minor release of PyPy interpreter. We highly recommend the latest patch release of each Python series. \u2014 \u2b50 \u2014 The generics library is part of the SOLID python family.","title":"Installation"},{"location":"installation/#installation","text":"The generics library is available on PyPI. To install it run: pip install -U generics We use semantic release to publish packages as soon as pull requests land to the master branch. It's not necessary to use develompment version of the library. We officially support three last minor releases of CPython interpreter and last minor release of PyPy interpreter. We highly recommend the latest patch release of each Python series. \u2014 \u2b50 \u2014 The generics library is part of the SOLID python family.","title":"Installation"},{"location":"private/","text":"Private \u00b6 Why \u00b6 Object-oriented programming has a lot of advantages over procedural programming. The one of these advantages is encapsulation of data. In python encapsulation is implemented without information hiding . We lack this feature and want to fix it. Leading underscores \u00b6 The naming convention with leading underscores from pep8 does not work the way we want. For example, the code below will not hide class attributes. >>> class User : ... def __init__ ( self , name ): ... self . _name = name ... ... def greet ( self ): ... return f \"Hello, { self . _name } \" >>> user = User ( \"Jeff\" ) >>> user . greet () 'Hello, Jeff' >>> user . _name # No information hiding here :( 'Jeff' It may be a nice convention to have it in the code base, but it does not work (it does not make architecture any better) it harms readability (underscores are ugly) Principles \u00b6 All methods are public All attributes are private and hidden Static methods are forbidden Class methods should return instances Class methods can not be called on instancies Instance methods can not be called on classes At least one instance method is required At least one encapsulated attribute is required Implementation inheritance is forbidden Underscore names are forbidden Prefer immutable classes All methods are public \u00b6 The main purpose of objects in object-oriented programming is in behavior they could provide to the client code. Behavior intended by object could be expressed with its methods. Thus every instance and class method of the object is public. Class should be decorated with @private function. >>> from generics import private >>> @private ... class User : ... def __init__ ( self , name ): ... self . name = name ... ... def __repr__ ( self ): ... return ( ... self . __class__ . __name__ ... + \"(\" ... + \", \" . join ( k + \"=\" + repr ( v ) for k , v in self . __dict__ . items ()) ... + \")\" ... ) ... ... def greet ( self ): ... return f 'Hello, { self . name } ' >>> User Private(User) >>> user = User ( 'Jeff' ) >>> user Private(User(name='Jeff')) >>> user . greet () 'Hello, Jeff' All attributes are private and hidden \u00b6 The main advantage of objects in object-oriented programming is in encapsulation and information hiding . Procedural programming have a lot of problems related to coupling. All data flows directly through the execution flow. Every part of the code in this flow is highly coupled with each other because of the data they pass to each other. In opposite in the object-oriented programming we put parts of the data close to the parts of the code where it'll be used. Thus the execution flow sees only method calls. Client code does not know what data were encapsulated inside the object. And it's none of its business. Thus all attributes encapsulated inside the objects are private. The constructor is the only place where you can put anything inside the object. Own methods of the object (defined in its class) are free to use its attributes as usual. Attribute access in the client code will raise an exception. >>> user . name Traceback (most recent call last): ... AttributeError : 'Private(User)' object has no attribute 'name' Static methods are forbidden \u00b6 Good objects expose their behavior and hide their state. The behavior objects expose should be related to the state object hides. This metric is called cohesion. Static methods can't access the inner state of the object. That's why the behavior they expose doesn't relate to the object. Cohesion will go down. That's why we forbid static methods. If you need such behavior, put it outside of the class. If this behavior is necessary in the instance method of the original class, encapsulate it. Pass that new thing to the constructor and access it in methods. >>> from generics import private >>> @private ... class User : ... def __init__ ( self , name ): ... self . name = name ... ... def greet ( self ): ... return f 'Hello, { self . name } ' ... ... @staticmethod ... def is_bot (): ... return False Traceback (most recent call last): ... _generics.exceptions.GenericClassError : Do not use static methods (use composition instead) Class methods should return instances \u00b6 As we mentioned earlier, objects should expose behavior. Class methods do not have access to any kind of inner state sinse there is no object encapsulating it. Thus the only kind of behavior class method should be able to do is instantiation of the object. >>> from generics import private >>> @private ... class User : ... def __init__ ( self , name ): ... self . name = name ... ... def greet ( self ): ... return f 'Hello, { self . name } ' ... ... @classmethod ... def create ( cls ): ... pass >>> User . create () Traceback (most recent call last): ... _generics.exceptions.GenericInstanceError : 'create' classmethod should return an instance of the 'User' class Class methods can not be called on instancies \u00b6 As we explained earlier, classmethod could only be used to instantiate entities. The purpose of such methods is to implement some semantics in addition to arguments passed to this method. In that case, if we would call classmethod using instance attribute access, it would be conceptually wrong. Because, this method call will have no relation to the instance itself. It does not have an access to it or its private attributes. That's why we force all call methods to be accessed using class reference. >>> from generics import private >>> @private ... class User : ... def __init__ ( self , name ): ... self . name = name ... ... def greet ( self ): ... return f 'Hello, { self . name } ' ... ... @classmethod ... def create ( cls ): ... return cls ( 'Jeff' ) >>> user = User . create () >>> user . create () Traceback (most recent call last): ... _generics.exceptions.GenericInstanceError : Class methods can not be called on instances Instance methods can not be called on classes \u00b6 In some cases, it's technically possible to use instance methods as functions, if you pass value of self directly as argument. This behavior is hacky. That's why generics library forbid explicitly a call of instance methods using class attribute access. >>> from generics import private >>> @private ... class User : ... def __init__ ( self , name ): ... self . name = name ... ... def greet ( self ): ... return 'Hello, anonymous' >>> class AnotherUser : ... name = 'Jeff' >>> User . greet ( AnotherUser ()) Traceback (most recent call last): ... _generics.exceptions.GenericClassError : Instance methods can not be called on classes At least one instance method is required \u00b6 As we mention a couple of times earlier the main goal of the good objects is to expose behavior. If there is no methods defined on the class, it's not possible to expose any kind of behavior. The object becomes useless. Class methods does not count since it has a different purpose. >>> from generics import private >>> @private ... class User : ... def __init__ ( self , name ): ... self . name = name ... ... @classmethod ... def create ( cls ): ... pass Traceback (most recent call last): ... _generics.exceptions.GenericClassError : Define at least one instance method At least one encapsulated attribute is required \u00b6 The same as a previous one this rules exists because of the encapsulation restrictions. If your object does not encapsulate at least one attribute, it does not have any state. In that case behavior exposed by the object does not relate to the object itself. Thus there is no reason to define such kind of method on the class in the first place. >>> from generics import private >>> @private ... class User : ... ... def greet ( self ): ... return 'Hello, Jeff' Traceback (most recent call last): ... _generics.exceptions.GenericClassError : Define at least one encapsulated attribute Note generics library assumes that constructor of the decorated class will assign its arguments to the instance properties with same names. That's why encapsulated attributes are inferred from constructor arguments. Implementation inheritance is forbidden \u00b6 First of all, there are two types of inheritance - subtyping inheritance and implementation inheritance . It's nothing wrong with subtyping inheritance. It's used to create \"is a\" relationship between classes. It's a technique where you can say that this class is an implementation of this particular interface. abc.Meta is one of the possible approaches for implicit interface implementation in Python. It has alternatives like Duck typing and typing_extensions.Protocol . Yet again, it's nothing wrong with it if you want to design contracts in your codebase using abc.Meta . On the other hand, implementation inheritance was designed for code reuse in its heart. That's where things start to get out of hands. Implementation inheritance breaks encapsulation by its definition. That's why it's easy to end up with code like that: >>> from app import Entity >>> class User ( Entity ): ... database_table = 'users' ... json_fields = [ 'id' , 'name' , 'surname' , 'bio' ] ... permissions = [ 'can_read' , 'can_edit' ] ... query_string_params = [ 'user_*' ] Looking just at that code it's impossible to answer these simple yet important questions: What responsibilities it has? (What it do?) How to use this class? (What public methods does it have?) Everything is hidden from us in the base class. And it has its own base classes as well. You get where it's going. That's why we forbid implementation inheritance. >>> from generics import private >>> from app import Entity >>> @private ... class User ( Entity ): ... def __init__ ( self , name ): ... self . name = name ... ... def greet ( self ): ... return f 'Hello, { self . name } ' Traceback (most recent call last): ... _generics.exceptions.GenericClassError : Do not use inheritance (use composition instead) Note Subtyping inheritance with abc.Meta is not implemented yet. We have plans to implement it in the future. Underscore names are forbidden \u00b6 As we mentioned at the beginning of the document, Python has a convention for private attributes and methods to start with a single underscore ( _ ) character. This harms readability. Thus they are forbidden. The library hides everything properly anyway. The presence of private methods especially is a sign of bad design. That means that the class has too many layers of abstractions hidden in it. The intention to hide methods defined in the class means that they operate on a lower level of abstractions that the responsibility of the class belongs to. Instead of using the composition of objects and encapsulation, the author decides to use uglier names. That gives hope to the author that users will not use methods with ugly names in their code. A bad design indeed. >>> from generics import private >>> @private ... class User : ... def __init__ ( self , name , _surname ): ... self . name = name ... self . _surname = _surname ... ... def greet ( self ): ... return f 'Hello, { self . name } { self . _surname } ' Traceback (most recent call last): ... _generics.exceptions.GenericClassError : Do not use private attributes Prefer immutable classes \u00b6 Awoid changing inner state of the classes as much as possible. Way too many problems was caused because of changed data in unexpected parts of code. To deal with such problem we should respect transparency of the references. Always create new name for the new state . Instead of protecting different parts of the code with same conditional statements, make methods of a class return a new instance of the class if it need to change something. Bad : >>> from generics import private >>> @private ... class User : ... def __init__ ( self , name ): ... self . name = name ... ... def rename ( self , name ): ... self . name = name >>> User ( name = 'Jeff' ) . rename ( 'John' ) Good : >>> from generics import private >>> @private ... class User : ... def __init__ ( self , name ): ... self . name = name ... ... def __repr__ ( self ): ... return ( ... self . __class__ . __name__ ... + \"(\" ... + \", \" . join ( k + \"=\" + repr ( v ) for k , v in self . __dict__ . items ()) ... + \")\" ... ) ... ... def rename ( self , name ): ... return User ( name ) >>> User ( name = 'Jeff' ) . rename ( 'John' ) Private(User(name='John')) \u2014 \u2b50 \u2014 The generics library is part of the SOLID python family.","title":"Private"},{"location":"private/#private","text":"","title":"Private"},{"location":"private/#why","text":"Object-oriented programming has a lot of advantages over procedural programming. The one of these advantages is encapsulation of data. In python encapsulation is implemented without information hiding . We lack this feature and want to fix it.","title":"Why"},{"location":"private/#leading-underscores","text":"The naming convention with leading underscores from pep8 does not work the way we want. For example, the code below will not hide class attributes. >>> class User : ... def __init__ ( self , name ): ... self . _name = name ... ... def greet ( self ): ... return f \"Hello, { self . _name } \" >>> user = User ( \"Jeff\" ) >>> user . greet () 'Hello, Jeff' >>> user . _name # No information hiding here :( 'Jeff' It may be a nice convention to have it in the code base, but it does not work (it does not make architecture any better) it harms readability (underscores are ugly)","title":"Leading underscores"},{"location":"private/#principles","text":"All methods are public All attributes are private and hidden Static methods are forbidden Class methods should return instances Class methods can not be called on instancies Instance methods can not be called on classes At least one instance method is required At least one encapsulated attribute is required Implementation inheritance is forbidden Underscore names are forbidden Prefer immutable classes","title":"Principles"},{"location":"private/#all-methods-are-public","text":"The main purpose of objects in object-oriented programming is in behavior they could provide to the client code. Behavior intended by object could be expressed with its methods. Thus every instance and class method of the object is public. Class should be decorated with @private function. >>> from generics import private >>> @private ... class User : ... def __init__ ( self , name ): ... self . name = name ... ... def __repr__ ( self ): ... return ( ... self . __class__ . __name__ ... + \"(\" ... + \", \" . join ( k + \"=\" + repr ( v ) for k , v in self . __dict__ . items ()) ... + \")\" ... ) ... ... def greet ( self ): ... return f 'Hello, { self . name } ' >>> User Private(User) >>> user = User ( 'Jeff' ) >>> user Private(User(name='Jeff')) >>> user . greet () 'Hello, Jeff'","title":"All methods are public"},{"location":"private/#all-attributes-are-private-and-hidden","text":"The main advantage of objects in object-oriented programming is in encapsulation and information hiding . Procedural programming have a lot of problems related to coupling. All data flows directly through the execution flow. Every part of the code in this flow is highly coupled with each other because of the data they pass to each other. In opposite in the object-oriented programming we put parts of the data close to the parts of the code where it'll be used. Thus the execution flow sees only method calls. Client code does not know what data were encapsulated inside the object. And it's none of its business. Thus all attributes encapsulated inside the objects are private. The constructor is the only place where you can put anything inside the object. Own methods of the object (defined in its class) are free to use its attributes as usual. Attribute access in the client code will raise an exception. >>> user . name Traceback (most recent call last): ... AttributeError : 'Private(User)' object has no attribute 'name'","title":"All attributes are private and hidden"},{"location":"private/#static-methods-are-forbidden","text":"Good objects expose their behavior and hide their state. The behavior objects expose should be related to the state object hides. This metric is called cohesion. Static methods can't access the inner state of the object. That's why the behavior they expose doesn't relate to the object. Cohesion will go down. That's why we forbid static methods. If you need such behavior, put it outside of the class. If this behavior is necessary in the instance method of the original class, encapsulate it. Pass that new thing to the constructor and access it in methods. >>> from generics import private >>> @private ... class User : ... def __init__ ( self , name ): ... self . name = name ... ... def greet ( self ): ... return f 'Hello, { self . name } ' ... ... @staticmethod ... def is_bot (): ... return False Traceback (most recent call last): ... _generics.exceptions.GenericClassError : Do not use static methods (use composition instead)","title":"Static methods are forbidden"},{"location":"private/#class-methods-should-return-instances","text":"As we mentioned earlier, objects should expose behavior. Class methods do not have access to any kind of inner state sinse there is no object encapsulating it. Thus the only kind of behavior class method should be able to do is instantiation of the object. >>> from generics import private >>> @private ... class User : ... def __init__ ( self , name ): ... self . name = name ... ... def greet ( self ): ... return f 'Hello, { self . name } ' ... ... @classmethod ... def create ( cls ): ... pass >>> User . create () Traceback (most recent call last): ... _generics.exceptions.GenericInstanceError : 'create' classmethod should return an instance of the 'User' class","title":"Class methods should return instances"},{"location":"private/#class-methods-can-not-be-called-on-instancies","text":"As we explained earlier, classmethod could only be used to instantiate entities. The purpose of such methods is to implement some semantics in addition to arguments passed to this method. In that case, if we would call classmethod using instance attribute access, it would be conceptually wrong. Because, this method call will have no relation to the instance itself. It does not have an access to it or its private attributes. That's why we force all call methods to be accessed using class reference. >>> from generics import private >>> @private ... class User : ... def __init__ ( self , name ): ... self . name = name ... ... def greet ( self ): ... return f 'Hello, { self . name } ' ... ... @classmethod ... def create ( cls ): ... return cls ( 'Jeff' ) >>> user = User . create () >>> user . create () Traceback (most recent call last): ... _generics.exceptions.GenericInstanceError : Class methods can not be called on instances","title":"Class methods can not be called on instancies"},{"location":"private/#instance-methods-can-not-be-called-on-classes","text":"In some cases, it's technically possible to use instance methods as functions, if you pass value of self directly as argument. This behavior is hacky. That's why generics library forbid explicitly a call of instance methods using class attribute access. >>> from generics import private >>> @private ... class User : ... def __init__ ( self , name ): ... self . name = name ... ... def greet ( self ): ... return 'Hello, anonymous' >>> class AnotherUser : ... name = 'Jeff' >>> User . greet ( AnotherUser ()) Traceback (most recent call last): ... _generics.exceptions.GenericClassError : Instance methods can not be called on classes","title":"Instance methods can not be called on classes"},{"location":"private/#at-least-one-instance-method-is-required","text":"As we mention a couple of times earlier the main goal of the good objects is to expose behavior. If there is no methods defined on the class, it's not possible to expose any kind of behavior. The object becomes useless. Class methods does not count since it has a different purpose. >>> from generics import private >>> @private ... class User : ... def __init__ ( self , name ): ... self . name = name ... ... @classmethod ... def create ( cls ): ... pass Traceback (most recent call last): ... _generics.exceptions.GenericClassError : Define at least one instance method","title":"At least one instance method is required"},{"location":"private/#at-least-one-encapsulated-attribute-is-required","text":"The same as a previous one this rules exists because of the encapsulation restrictions. If your object does not encapsulate at least one attribute, it does not have any state. In that case behavior exposed by the object does not relate to the object itself. Thus there is no reason to define such kind of method on the class in the first place. >>> from generics import private >>> @private ... class User : ... ... def greet ( self ): ... return 'Hello, Jeff' Traceback (most recent call last): ... _generics.exceptions.GenericClassError : Define at least one encapsulated attribute Note generics library assumes that constructor of the decorated class will assign its arguments to the instance properties with same names. That's why encapsulated attributes are inferred from constructor arguments.","title":"At least one encapsulated attribute is required"},{"location":"private/#implementation-inheritance-is-forbidden","text":"First of all, there are two types of inheritance - subtyping inheritance and implementation inheritance . It's nothing wrong with subtyping inheritance. It's used to create \"is a\" relationship between classes. It's a technique where you can say that this class is an implementation of this particular interface. abc.Meta is one of the possible approaches for implicit interface implementation in Python. It has alternatives like Duck typing and typing_extensions.Protocol . Yet again, it's nothing wrong with it if you want to design contracts in your codebase using abc.Meta . On the other hand, implementation inheritance was designed for code reuse in its heart. That's where things start to get out of hands. Implementation inheritance breaks encapsulation by its definition. That's why it's easy to end up with code like that: >>> from app import Entity >>> class User ( Entity ): ... database_table = 'users' ... json_fields = [ 'id' , 'name' , 'surname' , 'bio' ] ... permissions = [ 'can_read' , 'can_edit' ] ... query_string_params = [ 'user_*' ] Looking just at that code it's impossible to answer these simple yet important questions: What responsibilities it has? (What it do?) How to use this class? (What public methods does it have?) Everything is hidden from us in the base class. And it has its own base classes as well. You get where it's going. That's why we forbid implementation inheritance. >>> from generics import private >>> from app import Entity >>> @private ... class User ( Entity ): ... def __init__ ( self , name ): ... self . name = name ... ... def greet ( self ): ... return f 'Hello, { self . name } ' Traceback (most recent call last): ... _generics.exceptions.GenericClassError : Do not use inheritance (use composition instead) Note Subtyping inheritance with abc.Meta is not implemented yet. We have plans to implement it in the future.","title":"Implementation inheritance is forbidden"},{"location":"private/#underscore-names-are-forbidden","text":"As we mentioned at the beginning of the document, Python has a convention for private attributes and methods to start with a single underscore ( _ ) character. This harms readability. Thus they are forbidden. The library hides everything properly anyway. The presence of private methods especially is a sign of bad design. That means that the class has too many layers of abstractions hidden in it. The intention to hide methods defined in the class means that they operate on a lower level of abstractions that the responsibility of the class belongs to. Instead of using the composition of objects and encapsulation, the author decides to use uglier names. That gives hope to the author that users will not use methods with ugly names in their code. A bad design indeed. >>> from generics import private >>> @private ... class User : ... def __init__ ( self , name , _surname ): ... self . name = name ... self . _surname = _surname ... ... def greet ( self ): ... return f 'Hello, { self . name } { self . _surname } ' Traceback (most recent call last): ... _generics.exceptions.GenericClassError : Do not use private attributes","title":"Underscore names are forbidden"},{"location":"private/#prefer-immutable-classes","text":"Awoid changing inner state of the classes as much as possible. Way too many problems was caused because of changed data in unexpected parts of code. To deal with such problem we should respect transparency of the references. Always create new name for the new state . Instead of protecting different parts of the code with same conditional statements, make methods of a class return a new instance of the class if it need to change something. Bad : >>> from generics import private >>> @private ... class User : ... def __init__ ( self , name ): ... self . name = name ... ... def rename ( self , name ): ... self . name = name >>> User ( name = 'Jeff' ) . rename ( 'John' ) Good : >>> from generics import private >>> @private ... class User : ... def __init__ ( self , name ): ... self . name = name ... ... def __repr__ ( self ): ... return ( ... self . __class__ . __name__ ... + \"(\" ... + \", \" . join ( k + \"=\" + repr ( v ) for k , v in self . __dict__ . items ()) ... + \")\" ... ) ... ... def rename ( self , name ): ... return User ( name ) >>> User ( name = 'Jeff' ) . rename ( 'John' ) Private(User(name='John')) \u2014 \u2b50 \u2014 The generics library is part of the SOLID python family.","title":"Prefer immutable classes"},{"location":"pydantic/","text":"Pydantic \u00b6 pydantic is a popular library for data validation. It could be used to define business entities of your domain if you want validation to be applied to data your entities encapsulate. It's possible to use a pydantic dataclasses to make defined entities compatible with generics library decorators. As with all previous examples we advice you to make your instances immutable. pydantic library has a first class support for immutability. Enable frozen setting on class and use replace function to copy instancies of it. >>> from pydantic.dataclasses import dataclass >>> from dataclasses import replace >>> from generics import private >>> @private ... @dataclass ( frozen = True ) ... class User : ... name : str ... ... def greet ( self ): ... return f \"Hello, { self . name } \" ... ... def rename ( self , name ): ... return replace ( self , name = name ) >>> User Private(User) >>> user = User ( \"Jeff\" ) >>> user Private(User(name='Jeff')) >>> user . greet () 'Hello, Jeff' >>> user . rename ( \"Kate\" ) User(name='Kate') Arguments validation would be applied at the object construction time. This behavior would match regular dataclasses created by pydantic . >>> from typing import Callable >>> @private ... @dataclass ( frozen = True ) ... class User : ... name : str ... console : Callable ... ... def greet ( self ): ... self . console ( f 'Hello, { self . name } ' ) >>> User ( name = 'Jeff' , console = print ) Private(User(name='Jeff', console=<built-in function print>)) >>> User ( name = 'Jeff' , console = True ) Traceback (most recent call last): ... pydantic.error_wrappers.ValidationError : 1 validation error for User console True is not callable (type=type_error.callable; value=True) \u2014 \u2b50 \u2014 The generics library is part of the SOLID python family.","title":"Pydantic"},{"location":"pydantic/#pydantic","text":"pydantic is a popular library for data validation. It could be used to define business entities of your domain if you want validation to be applied to data your entities encapsulate. It's possible to use a pydantic dataclasses to make defined entities compatible with generics library decorators. As with all previous examples we advice you to make your instances immutable. pydantic library has a first class support for immutability. Enable frozen setting on class and use replace function to copy instancies of it. >>> from pydantic.dataclasses import dataclass >>> from dataclasses import replace >>> from generics import private >>> @private ... @dataclass ( frozen = True ) ... class User : ... name : str ... ... def greet ( self ): ... return f \"Hello, { self . name } \" ... ... def rename ( self , name ): ... return replace ( self , name = name ) >>> User Private(User) >>> user = User ( \"Jeff\" ) >>> user Private(User(name='Jeff')) >>> user . greet () 'Hello, Jeff' >>> user . rename ( \"Kate\" ) User(name='Kate') Arguments validation would be applied at the object construction time. This behavior would match regular dataclasses created by pydantic . >>> from typing import Callable >>> @private ... @dataclass ( frozen = True ) ... class User : ... name : str ... console : Callable ... ... def greet ( self ): ... self . console ( f 'Hello, { self . name } ' ) >>> User ( name = 'Jeff' , console = print ) Private(User(name='Jeff', console=<built-in function print>)) >>> User ( name = 'Jeff' , console = True ) Traceback (most recent call last): ... pydantic.error_wrappers.ValidationError : 1 validation error for User console True is not callable (type=type_error.callable; value=True) \u2014 \u2b50 \u2014 The generics library is part of the SOLID python family.","title":"Pydantic"}]}