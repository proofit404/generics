{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Generics \u00b6 A classy toolkit designed with OOP in mind. Documentation | Source Code | Task Tracker In our opinion, main benefits of having objects implemented in the language are encapsulation and polymorphous. Classes that could be easily used in a composition are tricky to write. The generics library aims to help you in writing code with high quality. Pros \u00b6 Real private attributes without loosing the readability Leads to a better design forcing you to use encapsulation properly Makes writing quality code with high cohesion and low coupling easier Guides you to follow SOLID principles Example \u00b6 The generics library gives you an easy way to define private attributes on objects without loosing little nice things like readability. >>> from generics import private >>> @private ... class User : ... def __init__ ( self , name ): ... self . name = name ... ... def greet ( self ): ... return f \"Hello, { self . name } \" >>> user = User ( \"Jeff\" ) >>> user . greet () 'Hello, Jeff' >>> hasattr ( user , \"name\" ) False Questions \u00b6 If you have any questions, feel free to create an issue in our Task Tracker . We have the question label exactly for this purpose. Enterprise support \u00b6 If you have an issue with any version of the library, you can apply for a paid enterprise support contract. This will guarantee you that no breaking changes will happen to you. No matter how old version you're using at the moment. All necessary features and bug fixes will be backported in a way that serves your needs. Please contact proofit404@gmail.com if you're interested in it. License \u00b6 generics library is offered under the two clause BSD license. \u2014 \u2b50 \u2014","title":"Home"},{"location":"#generics","text":"A classy toolkit designed with OOP in mind. Documentation | Source Code | Task Tracker In our opinion, main benefits of having objects implemented in the language are encapsulation and polymorphous. Classes that could be easily used in a composition are tricky to write. The generics library aims to help you in writing code with high quality.","title":"Generics"},{"location":"#pros","text":"Real private attributes without loosing the readability Leads to a better design forcing you to use encapsulation properly Makes writing quality code with high cohesion and low coupling easier Guides you to follow SOLID principles","title":"Pros"},{"location":"#example","text":"The generics library gives you an easy way to define private attributes on objects without loosing little nice things like readability. >>> from generics import private >>> @private ... class User : ... def __init__ ( self , name ): ... self . name = name ... ... def greet ( self ): ... return f \"Hello, { self . name } \" >>> user = User ( \"Jeff\" ) >>> user . greet () 'Hello, Jeff' >>> hasattr ( user , \"name\" ) False","title":"Example"},{"location":"#questions","text":"If you have any questions, feel free to create an issue in our Task Tracker . We have the question label exactly for this purpose.","title":"Questions"},{"location":"#enterprise-support","text":"If you have an issue with any version of the library, you can apply for a paid enterprise support contract. This will guarantee you that no breaking changes will happen to you. No matter how old version you're using at the moment. All necessary features and bug fixes will be backported in a way that serves your needs. Please contact proofit404@gmail.com if you're interested in it.","title":"Enterprise support"},{"location":"#license","text":"generics library is offered under the two clause BSD license. \u2014 \u2b50 \u2014","title":"License"},{"location":"attrs/","text":"Attrs \u00b6 attrs is a well known library to define classes in a nicer & shorter way. generics library works out of the box with attrs . As with all previous examples we advice you to make your instances immutable. attrs library has a first class support for immutability. Enable frozen setting on class and use evolve function to copy instancies of it. >>> from attr import attrs , attrib , evolve >>> from generics import private >>> @private ... @attrs ( frozen = True ) ... class User : ... name = attrib () ... ... def greet ( self ): ... return f \"Hello, { self . name } \" ... ... def rename ( self , name ): ... return evolve ( self , name = name ) >>> User Private::User >>> user = User ( \"Jeff\" ) >>> user Private::User(name='Jeff') >>> user . greet () 'Hello, Jeff' >>> user . rename ( \"Kate\" ) Private::User(name='Kate') \u2014 \u2b50 \u2014","title":"Attrs"},{"location":"attrs/#attrs","text":"attrs is a well known library to define classes in a nicer & shorter way. generics library works out of the box with attrs . As with all previous examples we advice you to make your instances immutable. attrs library has a first class support for immutability. Enable frozen setting on class and use evolve function to copy instancies of it. >>> from attr import attrs , attrib , evolve >>> from generics import private >>> @private ... @attrs ( frozen = True ) ... class User : ... name = attrib () ... ... def greet ( self ): ... return f \"Hello, { self . name } \" ... ... def rename ( self , name ): ... return evolve ( self , name = name ) >>> User Private::User >>> user = User ( \"Jeff\" ) >>> user Private::User(name='Jeff') >>> user . greet () 'Hello, Jeff' >>> user . rename ( \"Kate\" ) Private::User(name='Kate') \u2014 \u2b50 \u2014","title":"Attrs"},{"location":"changelog/","text":"4.0.0 (2022-10-14) \u00b6 Code Refactoring \u00b6 drop abc.Meta subtyping #57 1ea34e5 Features \u00b6 deny class attributes #57 ee512f7 BREAKING CHANGES \u00b6 Inheritance of any kind is not allowed any more. If you are using abc.Meta , we suggest to use typing.Protocol instead. 3.9.0 (2022-07-24) \u00b6 Features \u00b6 deny keyword arguments in constructor #213 5d0c4e1 3.8.0 (2022-07-14) \u00b6 Features \u00b6 protect instances returned from methods #233 20d1703 3.7.0 (2022-07-14) \u00b6 Features \u00b6 implement methods representation #231 67927ce 3.6.0 (2022-07-13) \u00b6 Features \u00b6 implement @delegated decorator #77 916fd1f 3.5.0 (2022-05-28) \u00b6 Features \u00b6 protect from star args constructor #212 656d370 3.4.0 (2021-08-18) \u00b6 Features \u00b6 allow inheritance from interface #94 3.3.1 (2021-04-07) \u00b6 Bug Fixes \u00b6 ignore dunder class methods #223 3.3.0 (2021-02-17) \u00b6 Features \u00b6 deny to call class methods on instances #220 3.2.1 (2021-01-08) \u00b6 Bug Fixes \u00b6 allow private methods defined globally #215 3.2.0 (2021-01-06) \u00b6 Features \u00b6 rewrite without third-party libraries #200 3.1.0 (2020-11-20) \u00b6 Features \u00b6 support pypy interpreter #9 3.0.0 (2020-11-12) \u00b6 Build System \u00b6 add python 3.9 support #186 BREAKING CHANGES \u00b6 drop python 3.6 support. 2.0.0 (2020-08-30) \u00b6 Code Refactoring \u00b6 drop Python 2.7 and 3.4 support #134 BREAKING CHANGES \u00b6 Due to the our new policy of enterprise user support we will drop abandoned version of python and libraries we are integrated with as soon as they reach official end of life. 1.1.0 (2020-08-21) \u00b6 Features \u00b6 support dependencies library 1.0.1 (2020-08-06) \u00b6 Bug Fixes \u00b6 fake @defended and @delegated decorators 1.0.0 (2020-07-03) \u00b6 Features \u00b6 implement @private decorator \u2014 \u2b50 \u2014","title":"Changelog"},{"location":"changelog/#400-2022-10-14","text":"","title":"4.0.0 (2022-10-14)"},{"location":"changelog/#code-refactoring","text":"drop abc.Meta subtyping #57 1ea34e5","title":"Code Refactoring"},{"location":"changelog/#features","text":"deny class attributes #57 ee512f7","title":"Features"},{"location":"changelog/#breaking-changes","text":"Inheritance of any kind is not allowed any more. If you are using abc.Meta , we suggest to use typing.Protocol instead.","title":"BREAKING CHANGES"},{"location":"changelog/#390-2022-07-24","text":"","title":"3.9.0 (2022-07-24)"},{"location":"changelog/#features_1","text":"deny keyword arguments in constructor #213 5d0c4e1","title":"Features"},{"location":"changelog/#380-2022-07-14","text":"","title":"3.8.0 (2022-07-14)"},{"location":"changelog/#features_2","text":"protect instances returned from methods #233 20d1703","title":"Features"},{"location":"changelog/#370-2022-07-14","text":"","title":"3.7.0 (2022-07-14)"},{"location":"changelog/#features_3","text":"implement methods representation #231 67927ce","title":"Features"},{"location":"changelog/#360-2022-07-13","text":"","title":"3.6.0 (2022-07-13)"},{"location":"changelog/#features_4","text":"implement @delegated decorator #77 916fd1f","title":"Features"},{"location":"changelog/#350-2022-05-28","text":"","title":"3.5.0 (2022-05-28)"},{"location":"changelog/#features_5","text":"protect from star args constructor #212 656d370","title":"Features"},{"location":"changelog/#340-2021-08-18","text":"","title":"3.4.0 (2021-08-18)"},{"location":"changelog/#features_6","text":"allow inheritance from interface #94","title":"Features"},{"location":"changelog/#331-2021-04-07","text":"","title":"3.3.1 (2021-04-07)"},{"location":"changelog/#bug-fixes","text":"ignore dunder class methods #223","title":"Bug Fixes"},{"location":"changelog/#330-2021-02-17","text":"","title":"3.3.0 (2021-02-17)"},{"location":"changelog/#features_7","text":"deny to call class methods on instances #220","title":"Features"},{"location":"changelog/#321-2021-01-08","text":"","title":"3.2.1 (2021-01-08)"},{"location":"changelog/#bug-fixes_1","text":"allow private methods defined globally #215","title":"Bug Fixes"},{"location":"changelog/#320-2021-01-06","text":"","title":"3.2.0 (2021-01-06)"},{"location":"changelog/#features_8","text":"rewrite without third-party libraries #200","title":"Features"},{"location":"changelog/#310-2020-11-20","text":"","title":"3.1.0 (2020-11-20)"},{"location":"changelog/#features_9","text":"support pypy interpreter #9","title":"Features"},{"location":"changelog/#300-2020-11-12","text":"","title":"3.0.0 (2020-11-12)"},{"location":"changelog/#build-system","text":"add python 3.9 support #186","title":"Build System"},{"location":"changelog/#breaking-changes_1","text":"drop python 3.6 support.","title":"BREAKING CHANGES"},{"location":"changelog/#200-2020-08-30","text":"","title":"2.0.0 (2020-08-30)"},{"location":"changelog/#code-refactoring_1","text":"drop Python 2.7 and 3.4 support #134","title":"Code Refactoring"},{"location":"changelog/#breaking-changes_2","text":"Due to the our new policy of enterprise user support we will drop abandoned version of python and libraries we are integrated with as soon as they reach official end of life.","title":"BREAKING CHANGES"},{"location":"changelog/#110-2020-08-21","text":"","title":"1.1.0 (2020-08-21)"},{"location":"changelog/#features_10","text":"support dependencies library","title":"Features"},{"location":"changelog/#101-2020-08-06","text":"","title":"1.0.1 (2020-08-06)"},{"location":"changelog/#bug-fixes_2","text":"fake @defended and @delegated decorators","title":"Bug Fixes"},{"location":"changelog/#100-2020-07-03","text":"","title":"1.0.0 (2020-07-03)"},{"location":"changelog/#features_11","text":"implement @private decorator \u2014 \u2b50 \u2014","title":"Features"},{"location":"dataclasses/","text":"Dataclasses \u00b6 dataclasses is a simpler alternative to attrs from python standard library. generics works with it out of the box. As with all previous examples we advice you to make your instances immutable. dataclasses library has a first class support for immutability. Enable frozen setting on class and use replace function to copy instancies of it. >>> from dataclasses import dataclass , replace >>> from generics import private >>> @private ... @dataclass ( frozen = True ) ... class User : ... name : str ... ... def greet ( self ): ... return f \"Hello, { self . name } \" ... ... def rename ( self , name ): ... return replace ( self , name = name ) >>> User Private::User >>> user = User ( \"Jeff\" ) >>> user Private::User(name='Jeff') >>> user . greet () 'Hello, Jeff' >>> user . rename ( \"Kate\" ) Private::User(name='Kate') \u2014 \u2b50 \u2014","title":"Dataclasses"},{"location":"dataclasses/#dataclasses","text":"dataclasses is a simpler alternative to attrs from python standard library. generics works with it out of the box. As with all previous examples we advice you to make your instances immutable. dataclasses library has a first class support for immutability. Enable frozen setting on class and use replace function to copy instancies of it. >>> from dataclasses import dataclass , replace >>> from generics import private >>> @private ... @dataclass ( frozen = True ) ... class User : ... name : str ... ... def greet ( self ): ... return f \"Hello, { self . name } \" ... ... def rename ( self , name ): ... return replace ( self , name = name ) >>> User Private::User >>> user = User ( \"Jeff\" ) >>> user Private::User(name='Jeff') >>> user . greet () 'Hello, Jeff' >>> user . rename ( \"Kate\" ) Private::User(name='Kate') \u2014 \u2b50 \u2014","title":"Dataclasses"},{"location":"delegated/","text":"Delegated \u00b6 Why \u00b6 Decorator is a powerful pattern in the OOP world. It means to adjust behavior of the object, you suppose to encapsulate it inside another object. Adjusted behavior would be implemented in methods of the decorator object itself. However, there are a lot of challenges to make this pattern useful and easy when you need it. When you call methods of encapsulated object to execute original behavor of the method, it means your object delegates responsibility to it. Attributes you didn't touch \u00b6 Sometimes you don't need to override all of the encapsulated object methods. Python language itself has nice mechanism of __getattr__ method, where you could return attributes which isn't defined on the instance itself. Problem comes when you would try to use this mechanism with methods. Attribute access should return bound method. >>> class User : ... def __init__ ( self , name ): ... self . _name = name ... ... def greet ( self ): ... return f \"Hello, { self . _name } \" >>> class Decorator : ... def __init__ ( self , user ): ... self . _user = user ... ... def __getattr__ ( self , name ): ... boundmethod = getattr ( self . _user ) ... return boundmethod Principles \u00b6 Missing methods would be defined automatically Missing methods would be defined automatically \u00b6 When you need to adjust behavior only of a few methods of the class, there is no point to write dumb boilerplate methods that would pass arguments as is to the method of encapsulated object. Methods of encapsulated object would be defined on the delegated class automatically. >>> from datetime import date , timedelta >>> from generics import private , delegated >>> @private ... class User : ... def __init__ ( self , name , last_login ): ... self . name = name ... self . last_login = last_login ... ... def greet ( self ): ... return f 'Hello, { self . name } ' ... ... def is_active ( self ): ... return self . last_login >= date . today () - timedelta ( days = 30 ) >>> @delegated ( User ) ... class LoggedUser : ... def __init__ ( self , user ): ... self . user = user ... ... def greet ( self ): ... print ( f 'Greeting { self . user !r} ' ) >>> yesterday = date . today () - timedelta ( days = 1 ) >>> month_ago = date . today () - timedelta ( days = 31 ) >>> user = User ( 'Jeff' , yesterday ) >>> user . greet () 'Hello, Jeff' >>> user . is_active () True >>> logged_user = LoggedUser ( User ( 'Kate' , month_ago )) >>> logged_user . is_active () False \u2014 \u2b50 \u2014","title":"Delegated"},{"location":"delegated/#delegated","text":"","title":"Delegated"},{"location":"delegated/#why","text":"Decorator is a powerful pattern in the OOP world. It means to adjust behavior of the object, you suppose to encapsulate it inside another object. Adjusted behavior would be implemented in methods of the decorator object itself. However, there are a lot of challenges to make this pattern useful and easy when you need it. When you call methods of encapsulated object to execute original behavor of the method, it means your object delegates responsibility to it.","title":"Why"},{"location":"delegated/#attributes-you-didnt-touch","text":"Sometimes you don't need to override all of the encapsulated object methods. Python language itself has nice mechanism of __getattr__ method, where you could return attributes which isn't defined on the instance itself. Problem comes when you would try to use this mechanism with methods. Attribute access should return bound method. >>> class User : ... def __init__ ( self , name ): ... self . _name = name ... ... def greet ( self ): ... return f \"Hello, { self . _name } \" >>> class Decorator : ... def __init__ ( self , user ): ... self . _user = user ... ... def __getattr__ ( self , name ): ... boundmethod = getattr ( self . _user ) ... return boundmethod","title":"Attributes you didn't touch"},{"location":"delegated/#principles","text":"Missing methods would be defined automatically","title":"Principles"},{"location":"delegated/#missing-methods-would-be-defined-automatically","text":"When you need to adjust behavior only of a few methods of the class, there is no point to write dumb boilerplate methods that would pass arguments as is to the method of encapsulated object. Methods of encapsulated object would be defined on the delegated class automatically. >>> from datetime import date , timedelta >>> from generics import private , delegated >>> @private ... class User : ... def __init__ ( self , name , last_login ): ... self . name = name ... self . last_login = last_login ... ... def greet ( self ): ... return f 'Hello, { self . name } ' ... ... def is_active ( self ): ... return self . last_login >= date . today () - timedelta ( days = 30 ) >>> @delegated ( User ) ... class LoggedUser : ... def __init__ ( self , user ): ... self . user = user ... ... def greet ( self ): ... print ( f 'Greeting { self . user !r} ' ) >>> yesterday = date . today () - timedelta ( days = 1 ) >>> month_ago = date . today () - timedelta ( days = 31 ) >>> user = User ( 'Jeff' , yesterday ) >>> user . greet () 'Hello, Jeff' >>> user . is_active () True >>> logged_user = LoggedUser ( User ( 'Kate' , month_ago )) >>> logged_user . is_active () False \u2014 \u2b50 \u2014","title":"Missing methods would be defined automatically"},{"location":"dependencies/","text":"Dependencies \u00b6 It is possible to instantiate classes decorated with @private function via dependencies library. >>> from dependencies import Injector >>> from generics import private >>> @private ... class User : ... def __init__ ( self , name ): ... self . name = name ... ... def greet ( self ): ... return f \"Hello, { self . name } \" >>> class UserContainer ( Injector ): ... user = User ... name = \"Jeff\" >>> UserContainer . user . greet () 'Hello, Jeff' \u2014 \u2b50 \u2014","title":"Dependencies"},{"location":"dependencies/#dependencies","text":"It is possible to instantiate classes decorated with @private function via dependencies library. >>> from dependencies import Injector >>> from generics import private >>> @private ... class User : ... def __init__ ( self , name ): ... self . name = name ... ... def greet ( self ): ... return f \"Hello, { self . name } \" >>> class UserContainer ( Injector ): ... user = User ... name = \"Jeff\" >>> UserContainer . user . greet () 'Hello, Jeff' \u2014 \u2b50 \u2014","title":"Dependencies"},{"location":"installation/","text":"Installation \u00b6 The generics library is available on PyPI. To install it run: pip install -U generics We use semantic release to publish packages as soon as pull requests land to the release branch. It's not necessary to use develompment version of the library. We officially support three last minor releases of CPython interpreter and last minor release of PyPy interpreter. We highly recommend the latest patch release of each Python series. \u2014 \u2b50 \u2014","title":"Installation"},{"location":"installation/#installation","text":"The generics library is available on PyPI. To install it run: pip install -U generics We use semantic release to publish packages as soon as pull requests land to the release branch. It's not necessary to use develompment version of the library. We officially support three last minor releases of CPython interpreter and last minor release of PyPy interpreter. We highly recommend the latest patch release of each Python series. \u2014 \u2b50 \u2014","title":"Installation"},{"location":"private/","text":"Private \u00b6 Why \u00b6 Object-oriented programming has a lot of advantages over procedural programming. The one of these advantages is encapsulation of data. In python encapsulation is implemented without information hiding . We lack this feature and want to fix it. Leading underscores \u00b6 The naming convention with leading underscores from pep8 does not work the way we want. For example, the code below will not hide class attributes. >>> class User : ... def __init__ ( self , name ): ... self . _name = name ... ... def greet ( self ): ... return f \"Hello, { self . _name } \" >>> user = User ( \"Jeff\" ) >>> user . greet () 'Hello, Jeff' >>> user . _name # No information hiding here :( 'Jeff' It may be a nice convention to have it in the code base, but it does not work (it does not make architecture any better) it harms readability (underscores are ugly) Principles \u00b6 All methods are public All attributes are private and hidden Static methods are forbidden Class methods should return instances Class methods can not be called on instances Instance methods can return instances Instance methods can not be called on classes At least one instance method is required At least one encapsulated attribute is required Variable-length encapsulated attributes are forbidden Keyword encapsulated attributes are forbidden Implementation inheritance is forbidden Underscore names are forbidden Class attributes are forbidden Prefer immutable classes Methods would have representation All methods are public \u00b6 The main purpose of objects in object-oriented programming is in behavior they could provide to the client code. Behavior intended by object could be expressed with its methods. Thus every instance and class method of the object is public. Class should be decorated with @private function. >>> from generics import private >>> @private ... class User : ... def __init__ ( self , name ): ... self . name = name ... ... def __repr__ ( self ): ... return f \"User( { self . name =!r} )\" ... ... def greet ( self ): ... return f 'Hello, { self . name } ' >>> User Private::User >>> user = User ( 'Jeff' ) >>> user Private::User(self.name='Jeff') >>> user . greet () 'Hello, Jeff' All attributes are private and hidden \u00b6 The main advantage of objects in object-oriented programming is in encapsulation and information hiding . Procedural programming have a lot of problems related to coupling. All data flows directly through the execution flow. Every part of the code in this flow is highly coupled with each other because of the data they pass to each other. In opposite in the object-oriented programming we put parts of the data close to the parts of the code where it'll be used. Thus the execution flow sees only method calls. Client code does not know what data were encapsulated inside the object. And it's none of its business. Thus all attributes encapsulated inside the objects are private. The constructor is the only place where you can put anything inside the object. Own methods of the object (defined in its class) are free to use its attributes as usual. Attribute access in the client code will raise an exception. >>> user . name Traceback (most recent call last): ... AttributeError : 'Private::User' object has no attribute 'name' Static methods are forbidden \u00b6 Good objects expose their behavior and hide their state. The behavior objects expose should be related to the state object hides. This metric is called cohesion. Static methods can't access the inner state of the object. That's why the behavior they expose doesn't relate to the object. Cohesion will go down. That's why we forbid static methods. If you need such behavior, put it outside of the class. If this behavior is necessary in the instance method of the original class, encapsulate it. Pass that new thing to the constructor and access it in methods. >>> from generics import private >>> @private ... class User : ... def __init__ ( self , name ): ... self . name = name ... ... def greet ( self ): ... return f 'Hello, { self . name } ' ... ... @staticmethod ... def is_bot (): ... return False Traceback (most recent call last): ... _generics.exceptions.GenericClassError : Do not use static methods (use composition instead) Class methods should return instances \u00b6 As we mentioned earlier, objects should expose behavior. Class methods do not have access to any kind of inner state sinse there is no object encapsulating it. Thus the only kind of behavior class method should be able to do is instantiation of the object. >>> from generics import private >>> @private ... class User : ... def __init__ ( self , name ): ... self . name = name ... ... def greet ( self ): ... return f 'Hello, { self . name } ' ... ... @classmethod ... def create ( cls ): ... pass >>> User . create () Traceback (most recent call last): ... _generics.exceptions.GenericInstanceError : 'create' classmethod should return an instance of the 'User' class Class methods can not be called on instances \u00b6 As we explained earlier, classmethod could only be used to instantiate entities. The purpose of such methods is to implement some semantics in addition to arguments passed to this method. In that case, if we would call classmethod using instance attribute access, it would be conceptually wrong. Because, this method call will have no relation to the instance itself. It does not have an access to it or its private attributes. That's why we force all call methods to be accessed using class reference. >>> from generics import private >>> @private ... class User : ... def __init__ ( self , name ): ... self . name = name ... ... def greet ( self ): ... return f 'Hello, { self . name } ' ... ... @classmethod ... def create ( cls ): ... return cls ( 'Jeff' ) >>> user = User . create () >>> user . create () Traceback (most recent call last): ... _generics.exceptions.GenericInstanceError : Class methods can not be called on instances Instance methods can return instances \u00b6 In case your object return another instance of the same class from its method, this instance would be @private as well. This is a good practice to follow. For example, instead of assigning new value to the attributes (aka setters), create new instance of the class with necessary changes and return it from method. Immutability is a powerful technique, which would help you to build safe architecture suitable for multi-threaded applications. See more in Prefer immutable classes . Instance methods can not be called on classes \u00b6 In some cases, it's technically possible to use instance methods as functions, if you pass value of self directly as argument. This behavior is hacky. That's why generics library forbid explicitly a call of instance methods using class attribute access. >>> from generics import private >>> @private ... class User : ... def __init__ ( self , name ): ... self . name = name ... ... def greet ( self ): ... return 'Hello, anonymous' >>> class AnotherUser : ... name = 'Jeff' >>> User . greet ( AnotherUser ()) Traceback (most recent call last): ... _generics.exceptions.GenericClassError : Instance methods can not be called on classes At least one instance method is required \u00b6 As we mention a couple of times earlier the main goal of the good objects is to expose behavior. If there is no methods defined on the class, it's not possible to expose any kind of behavior. The object becomes useless. Class methods does not count since it has a different purpose. >>> from generics import private >>> @private ... class User : ... def __init__ ( self , name ): ... self . name = name ... ... @classmethod ... def create ( cls ): ... pass Traceback (most recent call last): ... _generics.exceptions.GenericClassError : Define at least one instance method At least one encapsulated attribute is required \u00b6 The same as a previous one this rules exists because of the encapsulation restrictions. If your object does not encapsulate at least one attribute, it does not have any state. In that case behavior exposed by the object does not relate to the object itself. Thus there is no reason to define such kind of method on the class in the first place. >>> from generics import private >>> @private ... class User : ... ... def greet ( self ): ... return 'Hello, Jeff' Traceback (most recent call last): ... _generics.exceptions.GenericClassError : Define at least one encapsulated attribute Note generics library assumes that constructor of the decorated class will assign its arguments to the instance properties with same names. That's why encapsulated attributes are inferred from constructor arguments. Variable-length encapsulated attributes are forbidden \u00b6 Classes should not encapsulate average set of attributes. This makes code hard to reason about. This makes object state unrepresented in the source code. >>> from generics import private >>> @private ... class User : ... ... def __init__ ( self , * args ): ... self . args = args ... ... def greet ( self ): ... return 'Hello, Jeff' Traceback (most recent call last): ... _generics.exceptions.GenericClassError : Class could not have variable encapsulated attribute Keyword encapsulated attributes are forbidden \u00b6 Classes should not encapsulate attributes which names defined outside of the class. This makes code hard to reason about. This makes object structure unrepresented in the source code. >>> from generics import private >>> @private ... class User : ... ... def __init__ ( self , ** kwargs ): ... self . kwargs = kwargs ... ... def greet ( self ): ... return 'Hello, Jeff' Traceback (most recent call last): ... _generics.exceptions.GenericClassError : Class could not have keyword encapsulated attribute Implementation inheritance is forbidden \u00b6 First of all, there are two types of inheritance - subtyping inheritance and implementation inheritance . It's nothing wrong with subtyping inheritance. It's used to create \"is a\" relationship between classes. It's a technique where you can say that this class is an implementation of this particular interface. abc.Meta is one of the possible approaches for implicit interface implementation in Python. It has alternatives like Duck typing and typing_extensions.Protocol . If you want to design contracts in your codebase using abc.Meta , we advice you not to do so. Protocol would make it possible to define contract close to the place where object of this interface would be used. The most practical place to put interface declaration. More importantly it would not create broken (from the point of logic) import graph and would not force you to create dumb top-down architecture. abc.Meta makes both of these goals hard to achieve. On the other hand, implementation inheritance was designed for code reuse in its heart. That's where things start to get out of hands. Implementation inheritance breaks encapsulation by its definition. That's why it's easy to end up with code like that: >>> from app import Entity >>> class User ( Entity ): ... database_table = 'users' ... json_fields = [ 'id' , 'name' , 'surname' , 'bio' ] ... permissions = [ 'can_read' , 'can_edit' ] ... query_string_params = [ 'user_*' ] Looking just at that code it's impossible to answer these simple yet important questions: What responsibilities it has? (What it do?) How to use this class? (What public methods does it have?) Everything is hidden from us in the base class. And it has its own base classes as well. You get where it's going. That's why we forbid implementation inheritance. >>> from generics import private >>> from app import Entity >>> @private ... class User ( Entity ): ... def __init__ ( self , name ): ... self . name = name ... ... def greet ( self ): ... return f 'Hello, { self . name } ' Traceback (most recent call last): ... _generics.exceptions.GenericClassError : Do not use inheritance (use composition instead) Note Subtyping inheritance with abc.Meta is not implemented yet. We have plans to implement it in the future. Underscore names are forbidden \u00b6 As we mentioned at the beginning of the document, Python has a convention for private attributes and methods to start with a single underscore ( _ ) character. This harms readability. Thus they are forbidden. The library hides everything properly anyway. The presence of private methods especially is a sign of bad design. That means that the class has too many layers of abstractions hidden in it. The intention to hide methods defined in the class means that they operate on a lower level of abstractions that the responsibility of the class belongs to. Instead of using the composition of objects and encapsulation, the author decides to use uglier names. That gives hope to the author that users will not use methods with ugly names in their code. A bad design indeed. >>> from generics import private >>> @private ... class User : ... def __init__ ( self , name , _surname ): ... self . name = name ... self . _surname = _surname ... ... def greet ( self ): ... return f 'Hello, { self . name } { self . _surname } ' Traceback (most recent call last): ... _generics.exceptions.GenericClassError : Do not use private attributes Class attributes are forbidden \u00b6 If you keep in mind that classes decorated with @private decorator does not expose instance attributes, you would agree that class attributes in that case became useless. Usually, it would be used as some kind of marker for external purposes. Let say some kind of regestry could access class attribute to make decision what to do with class. Bad : >>> class User : ... bot_flag = False >>> def register ( cls ): ... if cls . bot_flag : ... print ( 'extend bot registry' ) >>> register ( User ) Good : >>> from generics import private >>> @private ... class User : ... def __init__ ( self , name ): ... self . name = name ... ... def is_bot ( self ): ... return False >>> def register ( visitor ): ... if visitor . is_bot (): ... print ( 'extend bot registry' ) >>> register ( User ( 'Jeff' )) In some cases people tend to use class attributes as some kind of constants to be used by methods of the class. Most common intent for such style would be abbility to override that constant using inheritance. We consider this practice an antipattern as well. Our suggestion would be to move this constant to the default value of the keyword argument of the method. If you need this constant in more than one method of your class, it is a clear sign that your class is doing too much. It's a code smell related to the Single-responsibility principle . Do not define module level uppercase-named variable. Do not repeat same keyword argument in many methods of the same class. Instead of this you could extract logic related to the constant into a smaller low-level class. After that you would be able to encapsulate its instance into original class and remove existed duplication. Bad : >>> class User : ... active_status = 'active' ... ... def __init__ ( self , status ): ... self . status = status ... ... def is_active ( self ): ... return self . status == self . active_status >>> user = User ( 'banned' ) >>> user . is_active () False Good : >>> from generics import private >>> @private ... class User : ... def __init__ ( self , status ): ... self . status = status ... ... def is_active ( self , active_status = 'active' ): ... return self . status == active_status >>> user = User ( 'banned' ) >>> user . is_active () False Which that reasons in mind generics library deny class attributes to be defined on classes decorated with @private decorator. >>> from generics import private >>> @private ... class User : ... alive = True ... ... def __init__ ( self , name ): ... self . name = name ... ... def greet ( self ): ... return f 'Hello, { self . name } ' Traceback (most recent call last): ... _generics.exceptions.GenericClassError : Do not define attributes on classes Prefer immutable classes \u00b6 Awoid changing inner state of the classes as much as possible. Way too many problems was caused because of changed data in unexpected parts of code. To deal with such problem we should respect transparency of the references. Always create new name for the new state . Instead of protecting different parts of the code with same conditional statements, make methods of a class return a new instance of the class if it need to change something. Bad : >>> from generics import private >>> @private ... class User : ... def __init__ ( self , name ): ... self . name = name ... ... def rename ( self , name ): ... self . name = name >>> User ( name = 'Jeff' ) . rename ( 'John' ) Good : >>> from generics import private >>> @private ... class User : ... def __init__ ( self , name ): ... self . name = name ... ... def __repr__ ( self ): ... return f \"User( { self . name =!r} )\" ... ... def rename ( self , name ): ... return User ( name ) >>> User ( name = 'Jeff' ) . rename ( 'John' ) Private::User(self.name='John') Methods would have representation \u00b6 In some cases, instead of object composition people would create composition of callables. Usually, this happens when you pass bound method of one object into constructor of another object. Service objects tend to do this a lot. Most of the time they primary goal to trigger some action. Such objects are rarely interested in knowledge who would implement the action. To make service objects representation look nice, generics library provides representation to class and instance methods of @private classes. >>> @private ... class Registration : ... def __init__ ( self , send_message ): ... self . send_message = send_message ... ... def __repr__ ( self ): ... return f \"Registration( \\n { self . send_message =!r} \\n )\" ... ... def sign_up ( self , phone ): ... self . send_message ( phone ) >>> @private ... class Message : ... def __init__ ( self , text ): ... self . text = text ... ... def __repr__ ( self ): ... return f \"SignUp( { self . text =!r} )\" ... ... def send ( self , phone ): ... print ( f \"Message { self . text !r} was sent to { phone !r} \" ) >>> message = Message ( \"Welcome to the service\" ) >>> registration = Registration ( message . send ) >>> registration . sign_up ( \"911\" ) Message 'Welcome to the service' was sent to '911' >>> registration Private::Registration( self.send_message=Private::SignUp(self.text='Welcome to the service').send ) \u2014 \u2b50 \u2014","title":"Private"},{"location":"private/#private","text":"","title":"Private"},{"location":"private/#why","text":"Object-oriented programming has a lot of advantages over procedural programming. The one of these advantages is encapsulation of data. In python encapsulation is implemented without information hiding . We lack this feature and want to fix it.","title":"Why"},{"location":"private/#leading-underscores","text":"The naming convention with leading underscores from pep8 does not work the way we want. For example, the code below will not hide class attributes. >>> class User : ... def __init__ ( self , name ): ... self . _name = name ... ... def greet ( self ): ... return f \"Hello, { self . _name } \" >>> user = User ( \"Jeff\" ) >>> user . greet () 'Hello, Jeff' >>> user . _name # No information hiding here :( 'Jeff' It may be a nice convention to have it in the code base, but it does not work (it does not make architecture any better) it harms readability (underscores are ugly)","title":"Leading underscores"},{"location":"private/#principles","text":"All methods are public All attributes are private and hidden Static methods are forbidden Class methods should return instances Class methods can not be called on instances Instance methods can return instances Instance methods can not be called on classes At least one instance method is required At least one encapsulated attribute is required Variable-length encapsulated attributes are forbidden Keyword encapsulated attributes are forbidden Implementation inheritance is forbidden Underscore names are forbidden Class attributes are forbidden Prefer immutable classes Methods would have representation","title":"Principles"},{"location":"private/#all-methods-are-public","text":"The main purpose of objects in object-oriented programming is in behavior they could provide to the client code. Behavior intended by object could be expressed with its methods. Thus every instance and class method of the object is public. Class should be decorated with @private function. >>> from generics import private >>> @private ... class User : ... def __init__ ( self , name ): ... self . name = name ... ... def __repr__ ( self ): ... return f \"User( { self . name =!r} )\" ... ... def greet ( self ): ... return f 'Hello, { self . name } ' >>> User Private::User >>> user = User ( 'Jeff' ) >>> user Private::User(self.name='Jeff') >>> user . greet () 'Hello, Jeff'","title":"All methods are public"},{"location":"private/#all-attributes-are-private-and-hidden","text":"The main advantage of objects in object-oriented programming is in encapsulation and information hiding . Procedural programming have a lot of problems related to coupling. All data flows directly through the execution flow. Every part of the code in this flow is highly coupled with each other because of the data they pass to each other. In opposite in the object-oriented programming we put parts of the data close to the parts of the code where it'll be used. Thus the execution flow sees only method calls. Client code does not know what data were encapsulated inside the object. And it's none of its business. Thus all attributes encapsulated inside the objects are private. The constructor is the only place where you can put anything inside the object. Own methods of the object (defined in its class) are free to use its attributes as usual. Attribute access in the client code will raise an exception. >>> user . name Traceback (most recent call last): ... AttributeError : 'Private::User' object has no attribute 'name'","title":"All attributes are private and hidden"},{"location":"private/#static-methods-are-forbidden","text":"Good objects expose their behavior and hide their state. The behavior objects expose should be related to the state object hides. This metric is called cohesion. Static methods can't access the inner state of the object. That's why the behavior they expose doesn't relate to the object. Cohesion will go down. That's why we forbid static methods. If you need such behavior, put it outside of the class. If this behavior is necessary in the instance method of the original class, encapsulate it. Pass that new thing to the constructor and access it in methods. >>> from generics import private >>> @private ... class User : ... def __init__ ( self , name ): ... self . name = name ... ... def greet ( self ): ... return f 'Hello, { self . name } ' ... ... @staticmethod ... def is_bot (): ... return False Traceback (most recent call last): ... _generics.exceptions.GenericClassError : Do not use static methods (use composition instead)","title":"Static methods are forbidden"},{"location":"private/#class-methods-should-return-instances","text":"As we mentioned earlier, objects should expose behavior. Class methods do not have access to any kind of inner state sinse there is no object encapsulating it. Thus the only kind of behavior class method should be able to do is instantiation of the object. >>> from generics import private >>> @private ... class User : ... def __init__ ( self , name ): ... self . name = name ... ... def greet ( self ): ... return f 'Hello, { self . name } ' ... ... @classmethod ... def create ( cls ): ... pass >>> User . create () Traceback (most recent call last): ... _generics.exceptions.GenericInstanceError : 'create' classmethod should return an instance of the 'User' class","title":"Class methods should return instances"},{"location":"private/#class-methods-can-not-be-called-on-instances","text":"As we explained earlier, classmethod could only be used to instantiate entities. The purpose of such methods is to implement some semantics in addition to arguments passed to this method. In that case, if we would call classmethod using instance attribute access, it would be conceptually wrong. Because, this method call will have no relation to the instance itself. It does not have an access to it or its private attributes. That's why we force all call methods to be accessed using class reference. >>> from generics import private >>> @private ... class User : ... def __init__ ( self , name ): ... self . name = name ... ... def greet ( self ): ... return f 'Hello, { self . name } ' ... ... @classmethod ... def create ( cls ): ... return cls ( 'Jeff' ) >>> user = User . create () >>> user . create () Traceback (most recent call last): ... _generics.exceptions.GenericInstanceError : Class methods can not be called on instances","title":"Class methods can not be called on instances"},{"location":"private/#instance-methods-can-return-instances","text":"In case your object return another instance of the same class from its method, this instance would be @private as well. This is a good practice to follow. For example, instead of assigning new value to the attributes (aka setters), create new instance of the class with necessary changes and return it from method. Immutability is a powerful technique, which would help you to build safe architecture suitable for multi-threaded applications. See more in Prefer immutable classes .","title":"Instance methods can return instances"},{"location":"private/#instance-methods-can-not-be-called-on-classes","text":"In some cases, it's technically possible to use instance methods as functions, if you pass value of self directly as argument. This behavior is hacky. That's why generics library forbid explicitly a call of instance methods using class attribute access. >>> from generics import private >>> @private ... class User : ... def __init__ ( self , name ): ... self . name = name ... ... def greet ( self ): ... return 'Hello, anonymous' >>> class AnotherUser : ... name = 'Jeff' >>> User . greet ( AnotherUser ()) Traceback (most recent call last): ... _generics.exceptions.GenericClassError : Instance methods can not be called on classes","title":"Instance methods can not be called on classes"},{"location":"private/#at-least-one-instance-method-is-required","text":"As we mention a couple of times earlier the main goal of the good objects is to expose behavior. If there is no methods defined on the class, it's not possible to expose any kind of behavior. The object becomes useless. Class methods does not count since it has a different purpose. >>> from generics import private >>> @private ... class User : ... def __init__ ( self , name ): ... self . name = name ... ... @classmethod ... def create ( cls ): ... pass Traceback (most recent call last): ... _generics.exceptions.GenericClassError : Define at least one instance method","title":"At least one instance method is required"},{"location":"private/#at-least-one-encapsulated-attribute-is-required","text":"The same as a previous one this rules exists because of the encapsulation restrictions. If your object does not encapsulate at least one attribute, it does not have any state. In that case behavior exposed by the object does not relate to the object itself. Thus there is no reason to define such kind of method on the class in the first place. >>> from generics import private >>> @private ... class User : ... ... def greet ( self ): ... return 'Hello, Jeff' Traceback (most recent call last): ... _generics.exceptions.GenericClassError : Define at least one encapsulated attribute Note generics library assumes that constructor of the decorated class will assign its arguments to the instance properties with same names. That's why encapsulated attributes are inferred from constructor arguments.","title":"At least one encapsulated attribute is required"},{"location":"private/#variable-length-encapsulated-attributes-are-forbidden","text":"Classes should not encapsulate average set of attributes. This makes code hard to reason about. This makes object state unrepresented in the source code. >>> from generics import private >>> @private ... class User : ... ... def __init__ ( self , * args ): ... self . args = args ... ... def greet ( self ): ... return 'Hello, Jeff' Traceback (most recent call last): ... _generics.exceptions.GenericClassError : Class could not have variable encapsulated attribute","title":"Variable-length encapsulated attributes are forbidden"},{"location":"private/#keyword-encapsulated-attributes-are-forbidden","text":"Classes should not encapsulate attributes which names defined outside of the class. This makes code hard to reason about. This makes object structure unrepresented in the source code. >>> from generics import private >>> @private ... class User : ... ... def __init__ ( self , ** kwargs ): ... self . kwargs = kwargs ... ... def greet ( self ): ... return 'Hello, Jeff' Traceback (most recent call last): ... _generics.exceptions.GenericClassError : Class could not have keyword encapsulated attribute","title":"Keyword encapsulated attributes are forbidden"},{"location":"private/#implementation-inheritance-is-forbidden","text":"First of all, there are two types of inheritance - subtyping inheritance and implementation inheritance . It's nothing wrong with subtyping inheritance. It's used to create \"is a\" relationship between classes. It's a technique where you can say that this class is an implementation of this particular interface. abc.Meta is one of the possible approaches for implicit interface implementation in Python. It has alternatives like Duck typing and typing_extensions.Protocol . If you want to design contracts in your codebase using abc.Meta , we advice you not to do so. Protocol would make it possible to define contract close to the place where object of this interface would be used. The most practical place to put interface declaration. More importantly it would not create broken (from the point of logic) import graph and would not force you to create dumb top-down architecture. abc.Meta makes both of these goals hard to achieve. On the other hand, implementation inheritance was designed for code reuse in its heart. That's where things start to get out of hands. Implementation inheritance breaks encapsulation by its definition. That's why it's easy to end up with code like that: >>> from app import Entity >>> class User ( Entity ): ... database_table = 'users' ... json_fields = [ 'id' , 'name' , 'surname' , 'bio' ] ... permissions = [ 'can_read' , 'can_edit' ] ... query_string_params = [ 'user_*' ] Looking just at that code it's impossible to answer these simple yet important questions: What responsibilities it has? (What it do?) How to use this class? (What public methods does it have?) Everything is hidden from us in the base class. And it has its own base classes as well. You get where it's going. That's why we forbid implementation inheritance. >>> from generics import private >>> from app import Entity >>> @private ... class User ( Entity ): ... def __init__ ( self , name ): ... self . name = name ... ... def greet ( self ): ... return f 'Hello, { self . name } ' Traceback (most recent call last): ... _generics.exceptions.GenericClassError : Do not use inheritance (use composition instead) Note Subtyping inheritance with abc.Meta is not implemented yet. We have plans to implement it in the future.","title":"Implementation inheritance is forbidden"},{"location":"private/#underscore-names-are-forbidden","text":"As we mentioned at the beginning of the document, Python has a convention for private attributes and methods to start with a single underscore ( _ ) character. This harms readability. Thus they are forbidden. The library hides everything properly anyway. The presence of private methods especially is a sign of bad design. That means that the class has too many layers of abstractions hidden in it. The intention to hide methods defined in the class means that they operate on a lower level of abstractions that the responsibility of the class belongs to. Instead of using the composition of objects and encapsulation, the author decides to use uglier names. That gives hope to the author that users will not use methods with ugly names in their code. A bad design indeed. >>> from generics import private >>> @private ... class User : ... def __init__ ( self , name , _surname ): ... self . name = name ... self . _surname = _surname ... ... def greet ( self ): ... return f 'Hello, { self . name } { self . _surname } ' Traceback (most recent call last): ... _generics.exceptions.GenericClassError : Do not use private attributes","title":"Underscore names are forbidden"},{"location":"private/#class-attributes-are-forbidden","text":"If you keep in mind that classes decorated with @private decorator does not expose instance attributes, you would agree that class attributes in that case became useless. Usually, it would be used as some kind of marker for external purposes. Let say some kind of regestry could access class attribute to make decision what to do with class. Bad : >>> class User : ... bot_flag = False >>> def register ( cls ): ... if cls . bot_flag : ... print ( 'extend bot registry' ) >>> register ( User ) Good : >>> from generics import private >>> @private ... class User : ... def __init__ ( self , name ): ... self . name = name ... ... def is_bot ( self ): ... return False >>> def register ( visitor ): ... if visitor . is_bot (): ... print ( 'extend bot registry' ) >>> register ( User ( 'Jeff' )) In some cases people tend to use class attributes as some kind of constants to be used by methods of the class. Most common intent for such style would be abbility to override that constant using inheritance. We consider this practice an antipattern as well. Our suggestion would be to move this constant to the default value of the keyword argument of the method. If you need this constant in more than one method of your class, it is a clear sign that your class is doing too much. It's a code smell related to the Single-responsibility principle . Do not define module level uppercase-named variable. Do not repeat same keyword argument in many methods of the same class. Instead of this you could extract logic related to the constant into a smaller low-level class. After that you would be able to encapsulate its instance into original class and remove existed duplication. Bad : >>> class User : ... active_status = 'active' ... ... def __init__ ( self , status ): ... self . status = status ... ... def is_active ( self ): ... return self . status == self . active_status >>> user = User ( 'banned' ) >>> user . is_active () False Good : >>> from generics import private >>> @private ... class User : ... def __init__ ( self , status ): ... self . status = status ... ... def is_active ( self , active_status = 'active' ): ... return self . status == active_status >>> user = User ( 'banned' ) >>> user . is_active () False Which that reasons in mind generics library deny class attributes to be defined on classes decorated with @private decorator. >>> from generics import private >>> @private ... class User : ... alive = True ... ... def __init__ ( self , name ): ... self . name = name ... ... def greet ( self ): ... return f 'Hello, { self . name } ' Traceback (most recent call last): ... _generics.exceptions.GenericClassError : Do not define attributes on classes","title":"Class attributes are forbidden"},{"location":"private/#prefer-immutable-classes","text":"Awoid changing inner state of the classes as much as possible. Way too many problems was caused because of changed data in unexpected parts of code. To deal with such problem we should respect transparency of the references. Always create new name for the new state . Instead of protecting different parts of the code with same conditional statements, make methods of a class return a new instance of the class if it need to change something. Bad : >>> from generics import private >>> @private ... class User : ... def __init__ ( self , name ): ... self . name = name ... ... def rename ( self , name ): ... self . name = name >>> User ( name = 'Jeff' ) . rename ( 'John' ) Good : >>> from generics import private >>> @private ... class User : ... def __init__ ( self , name ): ... self . name = name ... ... def __repr__ ( self ): ... return f \"User( { self . name =!r} )\" ... ... def rename ( self , name ): ... return User ( name ) >>> User ( name = 'Jeff' ) . rename ( 'John' ) Private::User(self.name='John')","title":"Prefer immutable classes"},{"location":"private/#methods-would-have-representation","text":"In some cases, instead of object composition people would create composition of callables. Usually, this happens when you pass bound method of one object into constructor of another object. Service objects tend to do this a lot. Most of the time they primary goal to trigger some action. Such objects are rarely interested in knowledge who would implement the action. To make service objects representation look nice, generics library provides representation to class and instance methods of @private classes. >>> @private ... class Registration : ... def __init__ ( self , send_message ): ... self . send_message = send_message ... ... def __repr__ ( self ): ... return f \"Registration( \\n { self . send_message =!r} \\n )\" ... ... def sign_up ( self , phone ): ... self . send_message ( phone ) >>> @private ... class Message : ... def __init__ ( self , text ): ... self . text = text ... ... def __repr__ ( self ): ... return f \"SignUp( { self . text =!r} )\" ... ... def send ( self , phone ): ... print ( f \"Message { self . text !r} was sent to { phone !r} \" ) >>> message = Message ( \"Welcome to the service\" ) >>> registration = Registration ( message . send ) >>> registration . sign_up ( \"911\" ) Message 'Welcome to the service' was sent to '911' >>> registration Private::Registration( self.send_message=Private::SignUp(self.text='Welcome to the service').send ) \u2014 \u2b50 \u2014","title":"Methods would have representation"},{"location":"pydantic/","text":"Pydantic \u00b6 pydantic is a popular library for data validation. It could be used to define business entities of your domain if you want validation to be applied to data your entities encapsulate. It's possible to use a pydantic dataclasses to make defined entities compatible with generics library decorators. As with all previous examples we advice you to make your instances immutable. pydantic library has a first class support for immutability. Enable frozen setting on class and use replace function to copy instancies of it. >>> from pydantic.dataclasses import dataclass >>> from dataclasses import replace >>> from generics import private >>> @private ... @dataclass ( frozen = True ) ... class User : ... name : str ... ... def greet ( self ): ... return f \"Hello, { self . name } \" ... ... def rename ( self , name ): ... return replace ( self , name = name ) >>> User Private::User >>> user = User ( \"Jeff\" ) >>> user Private::User(name='Jeff') >>> user . greet () 'Hello, Jeff' >>> user . rename ( \"Kate\" ) Private::User(name='Kate') Arguments validation would be applied at the object construction time. This behavior would match regular dataclasses created by pydantic . >>> from typing import Callable >>> @private ... @dataclass ( frozen = True ) ... class User : ... name : str ... console : Callable ... ... def greet ( self ): ... self . console ( f 'Hello, { self . name } ' ) >>> User ( name = 'Jeff' , console = print ) Private::User(name='Jeff', console=<built-in function print>) >>> User ( name = 'Jeff' , console = True ) Traceback (most recent call last): ... pydantic.error_wrappers.ValidationError : 1 validation error for User console True is not callable (type=type_error.callable; value=True) \u2014 \u2b50 \u2014","title":"Pydantic"},{"location":"pydantic/#pydantic","text":"pydantic is a popular library for data validation. It could be used to define business entities of your domain if you want validation to be applied to data your entities encapsulate. It's possible to use a pydantic dataclasses to make defined entities compatible with generics library decorators. As with all previous examples we advice you to make your instances immutable. pydantic library has a first class support for immutability. Enable frozen setting on class and use replace function to copy instancies of it. >>> from pydantic.dataclasses import dataclass >>> from dataclasses import replace >>> from generics import private >>> @private ... @dataclass ( frozen = True ) ... class User : ... name : str ... ... def greet ( self ): ... return f \"Hello, { self . name } \" ... ... def rename ( self , name ): ... return replace ( self , name = name ) >>> User Private::User >>> user = User ( \"Jeff\" ) >>> user Private::User(name='Jeff') >>> user . greet () 'Hello, Jeff' >>> user . rename ( \"Kate\" ) Private::User(name='Kate') Arguments validation would be applied at the object construction time. This behavior would match regular dataclasses created by pydantic . >>> from typing import Callable >>> @private ... @dataclass ( frozen = True ) ... class User : ... name : str ... console : Callable ... ... def greet ( self ): ... self . console ( f 'Hello, { self . name } ' ) >>> User ( name = 'Jeff' , console = print ) Private::User(name='Jeff', console=<built-in function print>) >>> User ( name = 'Jeff' , console = True ) Traceback (most recent call last): ... pydantic.error_wrappers.ValidationError : 1 validation error for User console True is not callable (type=type_error.callable; value=True) \u2014 \u2b50 \u2014","title":"Pydantic"}]}